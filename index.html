<!DOCTYPE html>
<html lang="no">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script>
        if (/Mobi|Android/i.test(navigator.userAgent)) {
            window.location.replace('mobile.html');
        }
    </script>
    <title>G√•pings Mallorca Getaway - Semi-Automatic Configurator</title>
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://kasbohm.github.io/ggtm26/">
    <meta property="og:title" content="G√•pings Mallorca Getaway 2026">
    <meta property="og:description" content="Velg dine ruter, planlegg dagene og gj√∏r deg klar for en episk G√•pingtur p√• Mallorca i 2026! Elite eller mosjonist, eller kombiner!">
    <meta property="og:image" content="https://kasbohm.github.io/ggtm26/logo.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:image:alt" content="G√•pings Mallorca Getaway Logo">
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://kasbohm.github.io/ggtm26/">
    <meta property="twitter:title" content="G√•pings Mallorca Getaway 2026">
    <meta property="twitter:description" content="Velg dine ruter, planlegg dagene og gj√∏r deg klar for en episk G√•pingtur p√• Mallorca i 2026! Elite eller mosjonist, eller kombiner!">
    <meta property="twitter:image" content="https://kasbohm.github.io/ggtm26/logo.png">
    
    <!-- General Meta -->
    <meta name="description" content="Velg dine ruter, planlegg dagene og gj√∏r deg klar for en episk G√•pingtur p√• Mallorca i 2026! Elite eller mosjonist, eller kombiner!">
    <meta name="keywords" content="Mallorca, sykkel, sykkelferie, GPS, GPX, ruter, planlegging, G√•ping">
    <meta name="author" content="G√•ping">
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            height: 100vh;
            display: flex;
            flex-direction: column;
            
            background: linear-gradient(180deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
        }

        .header {
            background: linear-gradient(90deg, #ff00ff 0%, #00f5ff 50%, #ffaa00 100%);
            color: #0a0a0a;
            padding: 1rem 1.5rem;
            box-shadow: 0 4px 20px rgba(255, 0, 255, 0.5), 0 0 40px rgba(0, 245, 255, 0.3);
            position: relative;
            overflow: hidden;
        }

        .header::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(255, 0, 255, 0.1) 2px,
                rgba(255, 0, 255, 0.1) 4px
            );
            animation: scan 8s linear infinite;
        }

        @keyframes scan {
            0% { transform: translateY(0); }
            100% { transform: translateY(50px); }
        }

        .header h1 {
            font-size: 1.2rem;
            font-weight: 700;
            position: relative;
            z-index: 1;
            text-shadow: 0 0 10px rgba(255, 255, 0, 0.8), 0 0 20px rgba(255, 0, 255, 0.6);
            letter-spacing: 1px;
        }

        .controls {
            background: rgba(20, 20, 40, 0.95);
            padding: 1rem 1.5rem;
            border-bottom: 2px solid #ff00ff;
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
            box-shadow: 0 4px 15px rgba(255, 0, 255, 0.3);
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }

        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }

        .file-input-label {
            background: linear-gradient(135deg, #00f5ff 0%, #0080ff 100%);
            color: #0a0a0a;
            padding: 0.6rem 1.2rem;
            border-radius: 4px;
            cursor: pointer;
            display: inline-block;
            font-size: 0.9rem;
            font-weight: 700;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(0, 245, 255, 0.4);
            border: 2px solid #00f5ff;
        }

        .file-input-label:hover {
            background: linear-gradient(135deg, #00ffff 0%, #00aaff 100%);
            box-shadow: 0 6px 20px rgba(0, 245, 255, 0.6);
            transform: translateY(-2px);
        }

        .btn {
            background: linear-gradient(135deg, #ff00ff 0%, #ff0080 100%);
            color: white;
            padding: 0.6rem 1.2rem;
            border: 2px solid #ff00ff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 700;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(255, 0, 255, 0.4);
        }

        .btn:hover {
            background: linear-gradient(135deg, #ff00ff 0%, #ff00aa 100%);
            box-shadow: 0 6px 20px rgba(255, 0, 255, 0.6);
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #302b63 0%, #24243e 100%);
            border-color: #00f5ff;
            box-shadow: 0 4px 15px rgba(0, 245, 255, 0.3);
        }

        .btn-secondary:hover {
            background: linear-gradient(135deg, #3d3768 0%, #2e2e4a 100%);
            box-shadow: 0 6px 20px rgba(0, 245, 255, 0.5);
        }

        .main-content {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        #map {
            flex: 1;
            transition: background-color 0.3s;
        }

        #map.light-background {
            background: #f8f8f8;
        }

        .sidebar {
            width: 230px;
            background: white;
            border-left: 1px solid #e0e0e0;
            overflow-y: auto;
            padding: 1rem;
        }

        .route-item {
            background: #f8f9fa;
            border-radius: 6px;
            padding: 0.8rem;
            margin-bottom: 0.8rem;
            border-left: 4px solid;
            cursor: move;
            position: relative;
        }

        .route-item:hover {
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .route-item.dragging {
            opacity: 0.5;
        }

        .route-header {
            display: flex;
            align-items: center;
            gap: 0.8rem;
            margin-bottom: 0.5rem;
            position: relative;
        }

        .route-toggle {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .route-name {
            flex: 1;
            font-weight: 500;
            font-size: 0.9rem;
            word-break: break-word;
            padding-right: 1.5rem;
        }

        .remove-route {
            position: absolute;
            top: 0;
            right: 0;
            cursor: pointer;
            color: #e74c3c;
            font-weight: bold;
            padding: 0.2rem 0.5rem;
            background: white;
            border-radius: 3px;
            font-size: 0.9rem;
            z-index: 10;
        }

        .remove-route:hover {
            background: #e74c3c;
            color: white;
        }

        .route-stats {
            font-size: 0.75rem;
            color: #666;
            margin-top: 0.3rem;
        }

        .route-stats div {
            margin-bottom: 0.2rem;
        }

        .empty-state {
            text-align: center;
            padding: 2rem;
            color: #999;
        }

        .stats-summary {
            background: #e8f4f8;
            padding: 1rem;
            border-radius: 6px;
            margin-bottom: 1rem;
            font-size: 0.85rem;
        }

        .stats-summary strong {
            color: #2c3e50;
        }

        .days-overlay {
            position: absolute;
            top: 10px;
            left: 50px;
            right: 220px;
            z-index: 1000;
            background: white;
            padding: 0.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 12px rgba(0,0,0,0.3);
        }

        .days-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
            font-weight: 600;
            font-size: 0.9rem;
            color: #2c3e50;
        }

        .days-toggle {
            cursor: pointer;
            font-size: 1.2rem;
            user-select: none;
            padding: 0 0.3rem;
        }

        .days-content {
            display: flex;
            gap: 0.5rem;
            overflow-x: auto;
        }

        .days-content.collapsed {
            display: none;
        }

        .day-box {
            flex: 1;
            min-width: 150px;
            background: #f8f9fa;
            border-radius: 6px;
            padding: 0.6rem;
            border: 2px solid #ddd;
            transition: all 0.2s;
        }

        .day-box.drag-over {
            background: #e8f4f8;
            border-color: #3498db;
            transform: scale(1.02);
        }

        .day-box-header {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .day-title {
            font-weight: 700;
            font-size: 0.9rem;
            color: #34495e;
            text-align: center;
        }

        .day-stats-compact {
            font-size: 0.7rem;
            color: #7f8c8d;
            text-align: center;
        }

        .day-controls {
            display: flex;
            gap: 0.3rem;
            align-items: center;
            justify-content: center;
        }

        .day-select-btn {
            background: linear-gradient(135deg, #ffaa00, #ff8800);
            border: 2px solid #ffaa00;
            color: #0a0a0a;
            padding: 0.3rem 0.4rem;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 700;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(255,170,0,0.4);
            transition: all 0.3s;
            white-space: nowrap;
            flex: 1;
        }

        .day-select-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255,170,0,0.6);
        }

        .btn-download-day {
            background: #27ae60;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 0.4rem 0.6rem;
            font-size: 0.7rem;
            cursor: pointer;
            transition: background 0.2s;
            white-space: nowrap;
        }

        .btn-download-day:hover {
            background: #229954;
        }

        .btn-download-day:disabled {
            background: #95a5a6;
            cursor: not-allowed;
        }

        .btn-toggle-day {
            background: linear-gradient(135deg, #3498db, #2980b9);
            border: 2px solid #3498db;
            color: white;
            padding: 0.4rem 0.6rem;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
            white-space: nowrap;
        }

        .btn-toggle-day:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(52,152,219,0.6);
        }

        .btn-toggle-day.hidden {
            background: linear-gradient(135deg, #95a5a6, #7f8c8d);
            border-color: #95a5a6;
        }

        .day-content {
            display: flex;
            flex-direction: column;
            gap: 0.3rem;
        }

        .day-route-item {
            background: white;
            border-radius: 4px;
            padding: 0.4rem;
            font-size: 0.7rem;
            border-left: 3px solid;
            position: relative;
        }

        .day-route-item:hover {
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .day-route-name {
            font-weight: 500;
            margin-bottom: 0.1rem;
            padding-right: 1rem;
            word-break: break-word;
            font-size: 0.7rem;
            line-height: 1.2;
        }

        .day-route-stats {
            font-size: 0.65rem;
            color: #7f8c8d;
        }

        .remove-from-day {
            position: absolute;
            top: 0.2rem;
            right: 0.2rem;
            cursor: pointer;
            color: #e74c3c;
            font-weight: bold;
            padding: 0 0.2rem;
            line-height: 1;
            font-size: 0.9rem;
        }

        .remove-from-day:hover {
            color: #c0392b;
        }

        /* Splash Screen */
        .splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: black;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 99999;
            transition: all 0.8s ease-in-out;
        }

        .splash-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .splash-screen.minimized {
            top: auto;
            bottom: 10px;
            left: 10px;
            height: auto;
            width: auto;
            background: transparent;
            box-shadow: none;
            justify-content: flex-start;
            padding: 0.5rem;
        }

        .splash-logo {
            max-width: 80%;
            width: 600px;
            height: auto;
            animation: pulse 2s ease-in-out infinite;
            transition: all 0.8s ease-in-out;
        }

        .splash-screen.minimized .splash-logo {
            width: 150px;
            animation: none;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .splash-screen.minimized .splash-logo:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 12px rgba(0,0,0,0.5);
        }

        /* L√∏ypeprofil */
        .elevation-profile {
            position: fixed;
            bottom: 10px;
            right: 250px;
            width: 600px;
            height: 200px;
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid #00f5ff;
            border-radius: 8px;
            padding: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            z-index: 10000;
            display: none;
        }

        .elevation-profile.visible {
            display: block;
        }

        .elevation-profile-header {
            color: #00f5ff;
            font-size: 0.9rem;
            font-weight: 700;
            margin-bottom: 8px;
            text-shadow: 0 0 5px rgba(0,245,255,0.5);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .elevation-profile-close {
            cursor: pointer;
            color: #ff0080;
            font-size: 1.2rem;
            line-height: 1;
            padding: 0 5px;
        }

        .elevation-profile-close:hover {
            color: #ff00ff;
        }

        .elevation-profile-canvas {
            width: 100%;
            height: 160px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .splash-progress {
            width: 400px;
            max-width: 80%;
            margin-top: 3rem;
            transition: all 0.8s ease-in-out;
        }

        .splash-screen.minimized .splash-progress {
            display: none;
        }

        .splash-progress-bar {
            width: 100%;
            height: 12px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .splash-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00f5ff 0%, #ff00ff 50%, #ffaa00 100%);
            background-size: 200% 100%;
            animation: shimmer 2s linear infinite;
            border-radius: 10px;
            transition: width 0.3s ease;
        }

        @keyframes shimmer {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        .splash-text {
            color: #00f5ff;
            font-size: 0.9rem;
            margin-top: 1rem;
            text-align: center;
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 10px rgba(0, 245, 255, 0.5);
        }

        .map-layer-selector {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background: white;
            padding: 0.8rem;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .map-layer-selector label {
            display: block;
            margin-bottom: 0.5rem;
            font-size: 0.85rem;
            cursor: pointer;
        }

        .map-layer-selector input[type="radio"] {
            margin-right: 0.5rem;
        }

        /* Route Selector Modal */
        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.8);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: linear-gradient(180deg, #1a1a2e, #16213e);
            border: 2px solid #00f5ff;
            border-radius: 12px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            padding: 20px;
            box-shadow: 0 0 40px rgba(0,245,255,0.5);
        }

        .modal-header {
            color: #00f5ff;
            font-size: 1.3rem;
            font-weight: 700;
            margin-bottom: 15px;
            text-shadow: 0 0 10px rgba(0,245,255,0.8);
            text-align: center;
        }

        .route-selector {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .route-option {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            padding: 12px;
            background: rgba(48,43,99,0.5);
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .route-option.selected {
            background: rgba(0,245,255,0.2);
            border-color: #00f5ff;
            box-shadow: 0 0 15px rgba(0,245,255,0.4);
        }

        .route-option input[type="checkbox"] {
            width: 20px;
            height: 20px;
            margin-top: 2px;
            accent-color: #00f5ff;
            flex-shrink: 0;
        }

        .route-option label {
            flex: 1;
            position: relative;
            color: white;
            font-size: 0.9rem;
            cursor: pointer;
        }

        .route-name {
            font-weight: 700;
            color: #00f5ff;
            margin-bottom: 4px;
        }
        .route-header .route-name {
            color: #3200ff;
        }

        .route-details {
            font-size: 0.8rem;
            color: #ffaa00;
        }

        .modal-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .modal-btn {
            flex: 1;
            padding: 12px;
            border-radius: 8px;
            border: 2px solid;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 1rem;
        }

        .modal-btn.save {
            background: linear-gradient(135deg, #00ff88, #00cc66);
            border-color: #00ff88;
            color: #0a0a0a;
        }

        .modal-btn.cancel {
            background: transparent;
            border-color: #ff0080;
            color: #ff0080;
        }

        .modal-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,245,255,0.4);
        }

        .route-badge {
            position: absolute;
            top: 5px;
            right: -5px;
            background: gold;
            color: black;
            font-weight: bold;
            padding: 3px 8px;
            border-radius: 5px;
            transform: rotate(15deg);
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            font-size: 0.75rem;
        }

        .route-badge.best {
            background: #28a745; /* gr√∏nn */
            color: white;
        }

        .route-badge.worst {
            background: #ffc107; /* gul */
            color: black;
        }
       #confetti-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: visible;
            z-index: 9999;
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            opacity: 0.9;
            border-radius: 2px;
            animation: explode 1.5s forwards;
        }

        @keyframes explode {
            0% {
                transform: translate(0, 0) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translate(var(--x), var(--y)) rotate(720deg);
                opacity: 0;
            }
        }


    </style>
</head>
<body>
    
    <!-- Splash Screen -->
    <div class="splash-screen" id="splashScreen">
        <img src="logo.png" alt="G√•pings Mallorca Getaway" class="splash-logo" id="splashLogo" onclick="window.toggleSCPlayer && window.toggleSCPlayer()" title="Click to play music">
        <div class="splash-progress">
            <div class="splash-progress-bar">
                <div class="splash-progress-fill" id="splashProgressFill" style="width: 0%"></div>
            </div>
            <div class="splash-text" id="splashText">Initializing configurator...</div>
        </div>
    </div>

    <div class="header">
        <h1>üå¥ G√•pings Mallorca Getaway Semi-Automatic Configurator for Desktop Computers</h1>
    </div>

    <div class="controls">
        <div class="file-input-wrapper">
            <input type="file" id="gpxInput" accept=".gpx" multiple>
            <label for="gpxInput" class="file-input-label">üìÅ Last opp GPX-filer</label>
        </div>
        <button class="btn" style="background: #e67e22;" onclick="autoMakeElite()">‚ö° Auto-Make Elite (A)</button>
        <button class="btn" style="background: #3498db;" onclick="autoMakeMosjonist()">üö¥ Auto-Make Mosjonist (B)</button>
        <button class="btn btn-secondary" id="toggleMapBtn">üó∫Ô∏è Skjul kart</button>
        <button class="btn btn-secondary" id="hideAllBtn">üëÅÔ∏è Skjul alle spor</button>
        <button class="btn btn-secondary" id="showAllBtn">üëÅÔ∏è Vis alle spor</button>
        <button class="btn" id="clearBtn">üóëÔ∏è Fjern alle</button>
        <div id="fileCount" style="color: #666; font-size: 0.9rem; display: flex; gap: 1.5rem; flex-wrap: wrap;"></div>
    </div>

    <div class="main-content">
        <div id="map">
            <div class="days-overlay" id="daysOverlay">
                <div class="days-header">
                    <span>üìÖ Dager</span>
                    <span class="days-toggle" onclick="toggleDaysExpand()">‚ñº</span>
                </div>
                <div class="days-content" id="daysContent">
                    <div class="day-box" data-day-id="1" ondrop="dropOnDay(event)" ondragover="allowDrop(event)" ondragleave="dragLeave(event)">
                        <div class="day-box-header">
                            <div class="day-title">Dag 1 - Port de Soller</div>
                            <div class="day-stats-compact" id="day-1-stats"></div>
                            <div class="day-controls">
                                <button class="day-select-btn" onclick="openRouteSelector(1)">Velg ruter</button>
                                <button class="btn-download-day" onclick="downloadDayGPX(1)" title="Last ned dag som GPX">‚¨áÔ∏è</button>
                                <button class="btn-download-day" onclick="showElevationProfile(1)" title="Vis l√∏ypeprofil" style="background: #9b59b6;">üìä</button>
                                <button class="btn-toggle-day" id="toggle-day-1" onclick="toggleDayVisibility(1)">Skjul dag</button>
                            </div>
                        </div>
                        <div class="day-content" id="day-1-content"></div>
                    </div>

                    <div class="day-box" data-day-id="2" ondrop="dropOnDay(event)" ondragover="allowDrop(event)" ondragleave="dragLeave(event)">
                        <div class="day-box-header">
                            <div class="day-title">Dag 2 - Cap de Formentor</div>
                            <div class="day-stats-compact" id="day-2-stats"></div>
                            <div class="day-controls">
                                <button class="day-select-btn" onclick="openRouteSelector(2)">Velg ruter</button>
                                <button class="btn-download-day" onclick="downloadDayGPX(2)" title="Last ned dag som GPX">‚¨áÔ∏è</button>
                                <button class="btn-download-day" onclick="showElevationProfile(2)" title="Vis l√∏ypeprofil" style="background: #9b59b6;">üìä</button>
                                <button class="btn-toggle-day" id="toggle-day-2" onclick="toggleDayVisibility(2)">Skjul dag</button>
                            </div>
                        </div>
                        <div class="day-content" id="day-2-content"></div>
                    </div>

                    <div class="day-box" data-day-id="3" ondrop="dropOnDay(event)" ondragover="allowDrop(event)" ondragleave="dragLeave(event)">
                        <div class="day-box-header">
                            <div class="day-title">Dag 3 - Sa Calobra</div>
                            <div class="day-stats-compact" id="day-3-stats"></div>
                            <div class="day-controls">
                                <button class="day-select-btn" onclick="openRouteSelector(3)">Velg ruter</button>
                                <button class="btn-download-day" onclick="downloadDayGPX(3)" title="Last ned dag som GPX">‚¨áÔ∏è</button>
                                <button class="btn-download-day" onclick="showElevationProfile(3)" title="Vis l√∏ypeprofil" style="background: #9b59b6;">üìä</button>
                                <button class="btn-toggle-day" id="toggle-day-3" onclick="toggleDayVisibility(3)">Skjul dag</button>
                            </div>
                        </div>
                        <div class="day-content" id="day-3-content"></div>
                    </div>

                    <div class="day-box" data-day-id="4" ondrop="dropOnDay(event)" ondragover="allowDrop(event)" ondragleave="dragLeave(event)">
                        <div class="day-box-header">
                            <div class="day-title">Dag 4 - Puig Major</div>
                            <div class="day-stats-compact" id="day-4-stats"></div>
                            <div class="day-controls">
                                <button class="day-select-btn" onclick="openRouteSelector(4)">Velg ruter</button>
                                <button class="btn-download-day" onclick="downloadDayGPX(4)" title="Last ned dag som GPX">‚¨áÔ∏è</button>
                                <button class="btn-download-day" onclick="showElevationProfile(4)" title="Vis l√∏ypeprofil" style="background: #9b59b6;">üìä</button>
                                <button class="btn-toggle-day" id="toggle-day-4" onclick="toggleDayVisibility(4)">Skjul dag</button>
                            </div>
                        </div>
                        <div class="day-content" id="day-4-content"></div>
                    </div>
                </div>
            </div>
            <div class="map-layer-selector">
                <label><input type="radio" name="mapLayer" value="standard" checked onchange="changeMapLayer('standard')"> Standard</label>
                <label><input type="radio" name="mapLayer" value="cycle" onchange="changeMapLayer('cycle')"> CyclOSM (Sykkelvennlig)</label>
                <label><input type="radio" name="mapLayer" value="transport" onchange="changeMapLayer('transport')"> Transport (veier)</label>
                <label><input type="radio" name="mapLayer" value="satellite" onchange="changeMapLayer('satellite')"> Satellitt</label>
            </div>
        </div>
        <div class="sidebar">
            <div id="routeList"></div>
        </div>

        <!-- Route Selector Modal -->
        <div class="modal" id="routeModal" style="display: none;">
            <div class="modal-content">
                <div class="modal-header">Velg ruter for <span id="modalDayTitle">Dag 1</span></div>
                <div class="route-selector" id="routeSelector"></div>
                <div class="modal-actions">
                    <button class="modal-btn save" onclick="saveRouteSelection()">Lagre</button>
                    <button class="modal-btn cancel" onclick="closeRouteSelector()">Avbryt</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        let currentSelectingDay = 1;

        
        window.openRouteSelector = function(dayId) {
            currentSelectingDay = dayId;
            const modal = document.getElementById('routeModal');
            const selector = document.getElementById('routeSelector');
            const dayNames = ['Port de Soller', 'Cap de Formentor', 'Sa Calobra', 'Puig Major'];
            document.getElementById('modalDayTitle').textContent = `Dag ${dayId} - ${dayNames[dayId-1]}`;
            
            // Filter routes for current day from BUNDLED routes only
            const dayRoutes = routes.filter(r => {
                if (!r.isBundled) return false; // Only bundled routes
                const match = r.fileName.match(/GGTM26_D(\d+)_/);
                return match && parseInt(match[1]) === dayId;
            });
            
            const day = days.find(d => d.id === dayId);
            
            // F√∏r du l√∏kker gjennom dayRoutes
            let bestRoute = null;
            let worstRoute = null;

            dayRoutes.forEach(route => {
                const km = route.stats ? route.stats.distance : 0;
                const hm = route.stats ? route.stats.elevationGain : 0;
                const kmNum = Number(km);
                const hmNum = Number(hm);
                route.score = Math.round(kmNum + hmNum ); // enkel m√•te √• sammenligne totalt "verdi"
                console.log(`Route ${route.fileName}: ${km} km, ${hm} hm, score: ${route.score}`);
            });

            // Finn best og worst basert p√• score
            bestRoute = dayRoutes.reduce((max, route) => (route.score > max.score ? route : max), dayRoutes[0]);
            worstRoute = dayRoutes.reduce((min, route) => (route.score < min.score ? route : min), dayRoutes[0]);


            selector.innerHTML = '';
            dayRoutes.forEach(route => {
                const isSelected = day.routes.includes(route.id);
                const div = document.createElement('div');
                div.className = `route-option ${isSelected ? 'selected' : ''}`;
                
                // Parse filename
                const parts = route.fileName.replace('.gpx', '').split('_');
                let level = '';
                let levelIndex = -1;
                for (let i = 0; i < parts.length; i++) {
                    if (parts[i].match(/^D\d+$/)) {
                        level = parts[i + 1];
                        levelIndex = i + 1;
                        break;
                    }
                }
                
                const locationParts = [];
                for (let i = levelIndex + 1; i < parts.length; i++) {
                    if (parts[i].match(/^\d+km$/) || parts[i].match(/^\d+hm$/)) break;
                    locationParts.push(parts[i]);
                }
                
                let fromTo = locationParts.join(' ');
                const heliosIndex = locationParts.indexOf('Helios');
                
                if (heliosIndex !== -1) {
                    if (heliosIndex === 0) {
                        const destination = locationParts.slice(1).join(' ');
                        fromTo = `Helios > ${destination}`;
                    } else {
                        const origin = locationParts.slice(0, heliosIndex).join(' ');
                        fromTo = `${origin} > Helios`;
                    }
                }
                
                const name = `${fromTo} (${level})`;
                const km = route.stats ? route.stats.distance : '?';
                const hm = route.stats ? route.stats.elevationGain : '?';
                
                const isBest = route === bestRoute;
                const isWorst = route === worstRoute;

                const badgeHTML = isBest ? `<span class="route-badge best">Best Value!</span>` :
                                isWorst ? `<span class="route-badge worst">Most Beers!</span>` : '';


                div.innerHTML = `
                    <input type="checkbox" id="route-${route.id}" ${isSelected ? 'checked' : ''}>
                    <label for="route-${route.id}">
                        <div class="route-name">${name}</div>
                        <div class="route-details">${km} km | ‚¨ÜÔ∏è ${hm} m</div>
                        ${badgeHTML}
                    </label>
                `;
                div.onclick = (e) => {
                    if (e.target.tagName !== 'INPUT') {
                        const checkbox = div.querySelector('input');
                        const checked = document.querySelectorAll('.route-option input:checked').length;
                        if (!checkbox.checked && checked >= 2) {
                            alert('Maks 2 ruter per dag!');
                            return;
                        }
                        checkbox.checked = !checkbox.checked;
                        div.classList.toggle('selected', checkbox.checked);
                    } else {
                        const checked = document.querySelectorAll('.route-option input:checked').length;
                        if (e.target.checked && checked > 2) {
                            e.target.checked = false;
                            alert('Maks 2 ruter per dag!');
                            return;
                        }
                        div.classList.toggle('selected', e.target.checked);

                        if (div.classList.contains('selected') &&
                            div.querySelector('.route-badge.best')) {
                            triggerConfetti();
                        }
                    }
                };
                selector.appendChild(div);
            });
            
            modal.style.display = 'flex';
        };

        window.closeRouteSelector = function() {
            document.getElementById('routeModal').style.display = 'none';
        };

        window.saveRouteSelection = function() {
            const selected = Array.from(document.querySelectorAll('.route-option input:checked'))
                .map(cb => parseInt(cb.id.split('-')[1]));
            
            const day = days.find(d => d.id === currentSelectingDay);
            day.routes = selected;
            
            // Hide all routes first
            routes.forEach(route => {
                route.visible = false;
                route.polyline.remove();
                route.startMarker.remove();
                route.endMarker.remove();
            });
            
            // Show only routes in VISIBLE days
            days.forEach(d => {
                if (d.visible) {
                    d.routes.forEach(routeId => {
                        const route = routes.find(r => r.id === routeId);
                        if (route) {
                            route.visible = true;
                            route.polyline.addTo(map);
                            route.startMarker.addTo(map);
                            route.endMarker.addTo(map);
                        }
                    });
                }
            });
            
            updateRouteColors();
            updateSidebar();
            closeRouteSelector();
        };

        // Initialize map centered on Norway
        const map = L.map('map').setView([60.472, 8.4689], 6);

        // Define tile layers
        const tileLayers = {
            standard: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors',
                maxZoom: 19
            }),
            cycle: L.tileLayer('https://{s}.tile-cyclosm.openstreetmap.fr/cyclosm/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors, CyclOSM',
                maxZoom: 20
            }),
            transport: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors',
                maxZoom: 19
            }),
            satellite: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: '¬© Esri',
                maxZoom: 19
            })
        };

        let currentTileLayer = tileLayers.standard;
        currentTileLayer.addTo(map);

        window.changeMapLayer = function(layerName) {
            if (currentTileLayer) {
                map.removeLayer(currentTileLayer);
            }
            currentTileLayer = tileLayers[layerName];
            currentTileLayer.addTo(map);
        };

        let mapVisible = true;

        const routes = [];
        const colors = [
            '#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6',
            '#1abc9c', '#e67e22', '#34495e', '#16a085', '#c0392b',
            '#27ae60', '#2980b9', '#8e44ad', '#d35400', '#7f8c8d'
        ];

        // Days structure: each day contains route IDs
        const dayColors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12'];
        const days = [
            { id: 1, name: 'Dag 1', routes: [], visible: true, color: dayColors[0] },
            { id: 2, name: 'Dag 2', routes: [], visible: true, color: dayColors[1] },
            { id: 3, name: 'Dag 3', routes: [], visible: true, color: dayColors[2] },
            { id: 4, name: 'Dag 4', routes: [], visible: true, color: dayColors[3] }
        ];

        const bundledRouteFiles = [
            'GGTM26_D1_A_Helios_Port_de_Soller_107km_1800hm.gpx',
            'GGTM26_D1_A_Port_de_Soller_Helios_87km_1500hm.gpx',
            'GGTM26_D1_B_Helios_Port_de_Soller_66km_1000hm.gpx',
            'GGTM26_D1_B1_Port_de_Soller_Helios_40km_500hm.gpx',
            'GGTM26_D1_B2_Port_de_Soller_Helios_60km_1100hm.gpx',
            'GGTM26_D2_A_Cap_de_Formentor_Helios_125km_1300hm.gpx',
            'GGTM26_D2_A_Helios_Cap_de_Formentor_108km_1930hm.gpx',
            'GGTM26_D2_B_Helios_Cap_de_Formentor_83km_1000hm.gpx',
            'GGTM26_D2_B1_Cap_de_Formentor_Helios_(tog)_40km_500hm.gpx',
            'GGTM26_D2_B2_Cap_de_Formentor_Helios_(tog)_60km_1100hm.gpx',
            'GGTM26_D3_A_Helios_Sa_Calobra__105km_1900hm.gpx',
            'GGTM26_D3_A_Sa_Calobra__Helios_100km_2300hm.gpx',
            'GGTM26_D3_B_Helios_Sa_Calobra__75km_1100hm.gpx',
            'GGTM26_D3_B1_Sa_Calobra__Helios_70km_1000hm.gpx',
            'GGTM26_D3_B2_Sa_Calobra__Helios_90km_1500hm.gpx',
            'GGTM26_D4_A_Helios_Puig_Major__72km_2400hm.gpx',
            'GGTM26_D4_A_Puig_Major_Helios_100km_1700hm.gpx',
            'GGTM26_D4_B_Helios_Puig_Major__62km_1700hm.gpx',
            'GGTM26_D4_B_Puig_Major_Helios_76km_850hm.gpx'
        ];

        function parseGPX(xmlString) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlString, 'text/xml');
            
            const points = [];
            const trkpts = xmlDoc.getElementsByTagName('trkpt');
            
            for (let i = 0; i < trkpts.length; i++) {
                const lat = parseFloat(trkpts[i].getAttribute('lat'));
                const lon = parseFloat(trkpts[i].getAttribute('lon'));
                
                const eleNode = trkpts[i].getElementsByTagName('ele')[0];
                const ele = eleNode ? parseFloat(eleNode.textContent) : null;
                
                points.push({ lat, lon, ele });
            }
            
            return points;
        }

        async function enrichWithElevation(points) {
            const targetSamples = 50;
            const sampleRate = Math.max(1, Math.floor(points.length / targetSamples));
            const sampledIndices = [];
            
            for (let i = 0; i < points.length; i += sampleRate) {
                sampledIndices.push(i);
            }
            
            if (sampledIndices[sampledIndices.length - 1] !== points.length - 1) {
                sampledIndices.push(points.length - 1);
            }
            
            const sampledPoints = sampledIndices.map(i => points[i]);
            
            const locations = sampledPoints.map(p => ({
                latitude: p.lat,
                longitude: p.lon
            }));
            
            try {
                const response = await fetch('https://api.open-elevation.com/api/v1/lookup', {
                    method: 'POST',
                    headers: {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ locations })
                });
                
                if (!response.ok) throw new Error('Elevation API failed');
                
                const data = await response.json();
                
                data.results.forEach((result, idx) => {
                    const originalIdx = sampledIndices[idx];
                    points[originalIdx].ele = result.elevation;
                });
                
                for (let i = 0; i < sampledIndices.length - 1; i++) {
                    const startIdx = sampledIndices[i];
                    const endIdx = sampledIndices[i + 1];
                    const startEle = points[startIdx].ele;
                    const endEle = points[endIdx].ele;
                    
                    for (let j = startIdx + 1; j < endIdx; j++) {
                        const ratio = (j - startIdx) / (endIdx - startIdx);
                        points[j].ele = startEle + (endEle - startEle) * ratio;
                    }
                }
                
                return true;
            } catch (error) {
                console.error('Failed to enrich elevation:', error);
                return false;
            }
        }

        function calculateStats(points) {
            if (points.length < 2) return null;
            
            let distance = 0;
            let elevationGain = 0;
            let elevationLoss = 0;
            let minEle = Infinity;
            let maxEle = -Infinity;
            
            for (let i = 1; i < points.length; i++) {
                const p1 = points[i - 1];
                const p2 = points[i];
                
                const R = 6371000;
                const œÜ1 = p1.lat * Math.PI / 180;
                const œÜ2 = p2.lat * Math.PI / 180;
                const ŒîœÜ = (p2.lat - p1.lat) * Math.PI / 180;
                const ŒîŒª = (p2.lon - p1.lon) * Math.PI / 180;
                
                const a = Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) +
                         Math.cos(œÜ1) * Math.cos(œÜ2) *
                         Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                
                distance += R * c;
                
                if (p1.ele !== null && p2.ele !== null) {
                    const eleDiff = p2.ele - p1.ele;
                    if (eleDiff > 0) elevationGain += eleDiff;
                    else elevationLoss += Math.abs(eleDiff);
                    
                    minEle = Math.min(minEle, p1.ele, p2.ele);
                    maxEle = Math.max(maxEle, p1.ele, p2.ele);
                }
            }
            
            return {
                distance: (distance / 1000).toFixed(2),
                elevationGain: Math.round(elevationGain),
                elevationLoss: Math.round(elevationLoss),
                minEle: minEle === Infinity ? null : Math.round(minEle),
                maxEle: maxEle === -Infinity ? null : Math.round(maxEle)
            };
        }

        function calculateOverlap() {
            const routesInDays = new Set(days.flatMap(d => d.routes));
            const statsRoutes = routesInDays.size > 0 
                ? routes.filter(r => routesInDays.has(r.id))
                : routes.filter(r => r.visible);
            
            if (statsRoutes.length < 2) {
                return { overlapPercentage: 0, commonPercentage: 0 };
            }

            const routeCoords = statsRoutes.map(route => {
                return route.polyline.getLatLngs().map(ll => ({ lat: ll.lat, lng: ll.lng }));
            });

            const tolerance = 0.0005;
            let commonPoints = 0;
            const route1 = routeCoords[0];
            
            for (let i = 0; i < route1.length; i++) {
                const p1 = route1[i];
                let inAllRoutes = true;
                
                for (let r = 1; r < routeCoords.length; r++) {
                    const routePoints = routeCoords[r];
                    let foundInRoute = false;
                    
                    for (let j = 0; j < routePoints.length; j++) {
                        const p2 = routePoints[j];
                        const dist = Math.sqrt(
                            Math.pow(p1.lat - p2.lat, 2) + Math.pow(p1.lng - p2.lng, 2)
                        );
                        if (dist < tolerance) {
                            foundInRoute = true;
                            break;
                        }
                    }
                    if (!foundInRoute) {
                        inAllRoutes = false;
                        break;
                    }
                }
                if (inAllRoutes) commonPoints++;
            }

            let overlapPoints = 0, totalComparisons = 0;
            for (let r1 = 0; r1 < routeCoords.length; r1++) {
                for (let r2 = r1 + 1; r2 < routeCoords.length; r2++) {
                    const coords1 = routeCoords[r1];
                    const coords2 = routeCoords[r2];
                    for (let i = 0; i < coords1.length - 1; i++) {
                        const seg1Start = coords1[i];
                        const seg1End = coords1[i + 1];
                        const dir1 = { lat: seg1End.lat - seg1Start.lat, lng: seg1End.lng - seg1Start.lng };
                        
                        for (let j = 0; j < coords2.length - 1; j++) {
                            const seg2Start = coords2[j];
                            const seg2End = coords2[j + 1];
                            const dist = Math.sqrt(
                                Math.pow(seg1Start.lat - seg2Start.lat, 2) + 
                                Math.pow(seg1Start.lng - seg2Start.lng, 2)
                            );
                            if (dist < tolerance) {
                                const dir2 = { lat: seg2End.lat - seg2Start.lat, lng: seg2End.lng - seg2Start.lng };
                                const dotProduct = dir1.lat * dir2.lat + dir1.lng * dir2.lng;
                                if (dotProduct > 0) {
                                    overlapPoints++;
                                    break;
                                }
                            }
                        }
                    }
                    totalComparisons += coords1.length;
                }
            }
            
            const overlapPercentage = totalComparisons > 0 ? (overlapPoints / totalComparisons * 100) : 0;
            
            return {
                overlapPercentage: overlapPercentage.toFixed(1),
                commonPercentage: route1.length > 0 ? (commonPoints / route1.length * 100).toFixed(1) : 0
            };
        }

        function addRoute(fileName, points, color, isBundled = false) {
            const latLngs = points.map(p => [p.lat, p.lon]);
            
            const polyline = L.polyline(latLngs, {
                color: color,
                weight: 3,
                opacity: 0.7
            }).addTo(map);
            
            const startMarker = L.circleMarker(latLngs[0], {
                radius: 8,
                fillColor: '#2ecc71',
                color: '#27ae60',
                weight: 2,
                opacity: 0.9,
                fillOpacity: 0.8
            }).addTo(map);
            startMarker.bindTooltip(`${fileName}<br><strong>Start</strong>`, { permanent: false });
            
            const endMarker = L.circleMarker(latLngs[latLngs.length - 1], {
                radius: 8,
                fillColor: '#e74c3c',
                color: '#c0392b',
                weight: 2,
                opacity: 0.9,
                fillOpacity: 0.8
            }).addTo(map);
            endMarker.bindTooltip(`${fileName}<br><strong>Slutt</strong>`, { permanent: false });
            
            const stats = calculateStats(points);
            
            const route = {
                id: routes.length,
                fileName,
                gpxPoints: points,
                polyline,
                startMarker,
                endMarker,
                originalColor: color,
                color,
                visible: true,
                stats,
                isBundled: isBundled
            };
            
            routes.push(route);
            
            if (routes.length === 1) {
                map.fitBounds(polyline.getBounds());
            } else {
                const group = L.featureGroup(routes.map(r => r.polyline));
                map.fitBounds(group.getBounds());
            }
            
            updateSidebar();
        }

        function updateRouteColors() {
            days.forEach(day => {
                day.routes.forEach(routeId => {
                    const route = routes.find(r => r.id === routeId);
                    if (route) {
                        route.color = day.color;
                        route.polyline.setStyle({ color: day.color });
                    }
                });
            });
            
            const routesInDays = new Set(days.flatMap(d => d.routes));
            routes.forEach(route => {
                if (!routesInDays.has(route.id)) {
                    route.color = route.originalColor;
                    route.polyline.setStyle({ color: route.originalColor });
                }
            });
        }

        function toggleRoute(routeId) {
            const route = routes[routeId];
            route.visible = !route.visible;
            
            if (route.visible) {
                route.polyline.addTo(map);
                route.startMarker.addTo(map);
                route.endMarker.addTo(map);
            } else {
                route.polyline.remove();
                route.startMarker.remove();
                route.endMarker.remove();
            }
            
            updateSidebar();
        }

        function toggleMapBackground() {
            const btn = document.getElementById('toggleMapBtn');
            const mapElement = document.getElementById('map');
            
            if (mapVisible) {
                currentTileLayer.setOpacity(0);
                mapElement.classList.add('light-background');
                btn.textContent = 'üó∫Ô∏è Vis kart';
                btn.style.background = '#27ae60';
            } else {
                currentTileLayer.setOpacity(1);
                mapElement.classList.remove('light-background');
                btn.textContent = 'üó∫Ô∏è Skjul kart';
                btn.style.background = '#95a5a6';
            }
            
            mapVisible = !mapVisible;
        }

        function hideAllRoutes() {
            routes.forEach(route => {
                if (route.visible) {
                    route.visible = false;
                    route.polyline.remove();
                    route.startMarker.remove();
                    route.endMarker.remove();
                }
            });
            updateSidebar();
        }

        function showAllRoutes() {
            routes.forEach(route => {
                if (!route.visible) {
                    route.visible = true;
                    route.polyline.addTo(map);
                    route.startMarker.addTo(map);
                    route.endMarker.addTo(map);
                }
            });
            updateSidebar();
        }

        function updateSidebar() {
            const routeList = document.getElementById('routeList');
            const fileCountDiv = document.getElementById('fileCount');
            
            updateDayBoxes();
            
            // Get user-uploaded routes only (not bundled)
            const userRoutes = routes.filter(r => !r.isBundled);
            const routesInDays = new Set(days.flatMap(d => d.routes));
            
            if (userRoutes.length === 0) {
                routeList.innerHTML = '<div class="empty-state">Ingen opplastede ruter.<br>Last opp GPX-filer for √• dra de til dagene.</div>';
            } else {
                // Calculate stats for user routes
                let totalDistance = 0;
                let totalElevationGain = 0;
                
                userRoutes.forEach(route => {
                    if (route.stats) {
                        totalDistance += parseFloat(route.stats.distance);
                        totalElevationGain += route.stats.elevationGain || 0;
                    }
                });
                
                // Calculate overlap for user routes
                const userRoutesInDays = userRoutes.filter(r => routesInDays.has(r.id));
                let overlapHtml = '';
                if (userRoutesInDays.length >= 2) {
                    const overlapData = calculateOverlap();
                    overlapHtml = `<br><br><strong>Overlapp:</strong><br>
                    ${overlapData.overlapPercentage}% overlapp<br>
                    ${overlapData.commonPercentage}% felles segment`;
                }
                
                let html = `
                    <div class="stats-summary">
                        <strong>Opplastede ruter:</strong><br>
                        ${userRoutes.length} ${userRoutes.length === 1 ? 'rute' : 'ruter'}<br>
                        ${totalDistance.toFixed(1)} km kombinert<br>
                        ${totalElevationGain > 0 ? `‚¨ÜÔ∏è ${totalElevationGain} m` : ''}
                        ${overlapHtml}
                    </div>
                `;
                
                const sortedUserRoutes = [...userRoutes].sort((a, b) => 
                    a.fileName.localeCompare(b.fileName, 'no')
                );
                
                // Show user routes not in days
                const availableUserRoutes = sortedUserRoutes.filter(r => !routesInDays.has(r.id));
                
                availableUserRoutes.forEach(route => {
                    html += `
                        <div class="route-item" 
                             style="border-left-color: ${route.color}; ${!route.visible ? 'opacity: 0.5;' : ''}"
                             draggable="true"
                             ondragstart="dragStart(event, ${route.id})">
                            <div class="route-header">
                                <input type="checkbox" 
                                       class="route-toggle" 
                                       ${route.visible ? 'checked' : ''} 
                                       onchange="toggleRoute(${route.id})">
                                <div class="route-name">${route.fileName}</div>
                                <span class="remove-route" onclick="removeRoute(${route.id}); event.stopPropagation();" title="Fjern rute">‚úï</span>
                            </div>
                            ${route.stats ? `
                                <div class="route-stats">
                                    <div>üìè ${route.stats.distance} km</div>
                                    ${route.stats.elevationGain ? `<div>‚¨ÜÔ∏è ${route.stats.elevationGain} m</div>` : ''}
                                    ${route.stats.minEle !== null ? `<div>üèîÔ∏è ${route.stats.minEle} - ${route.stats.maxEle} moh</div>` : ''}
                                </div>
                            ` : ''}
                        </div>
                    `;
                });
                
                routeList.innerHTML = html;
            }
            
            // Update file count for ALL routes (bundled + user)
            let statsRoutes;
            if (routesInDays.size > 0) {
                statsRoutes = routes.filter(r => routesInDays.has(r.id));
            } else {
                statsRoutes = routes.filter(r => r.visible);
            }
            
            let totalDistance = 0;
            let totalElevationGain = 0;
            
            statsRoutes.forEach(route => {
                if (route.stats) {
                    totalDistance += parseFloat(route.stats.distance);
                    totalElevationGain += route.stats.elevationGain || 0;
                }
            });
            
            const overlapData = calculateOverlap();
            
            let statsHtml = `<strong>${routes.length} ${routes.length === 1 ? 'rute' : 'ruter'}</strong>`;
            
            if (statsRoutes.length > 0) {
                if (routesInDays.size > 0) {
                    statsHtml += ` <span style="color: #27ae60;">(${statsRoutes.length} valgt)</span>`;
                } else {
                    statsHtml += ` <span style="color: #27ae60;">(${statsRoutes.length} synlig)</span>`;
                }
                statsHtml += ` | <strong>${totalDistance.toFixed(1)} km</strong>`;
                
                const hasElevation = statsRoutes.some(r => r.stats && r.stats.elevationGain > 0);
                if (hasElevation && totalElevationGain > 0) {
                    statsHtml += ` | <strong>‚¨ÜÔ∏è ${totalElevationGain.toLocaleString('no-NO')} m</strong>`;
                }
                
                if (statsRoutes.length >= 2) {
                    statsHtml += ` | Overlapp: <strong>${overlapData.overlapPercentage}%</strong>`;
                    if (overlapData.commonPercentage > 0) {
                        statsHtml += ` <span style="color: #e67e22;">(Felles: ${overlapData.commonPercentage}%)</span>`;
                    }
                }
            }
            
            fileCountDiv.innerHTML = statsHtml;
        }

        function updateDayBoxes() {
            days.forEach(day => {
                const contentDiv = document.getElementById(`day-${day.id}-content`);
                const statsDiv = document.getElementById(`day-${day.id}-stats`);
                const toggleBtn = document.getElementById(`toggle-day-${day.id}`);
                if (!contentDiv) return;
                
                const dayRoutes = day.routes.map(routeId => routes.find(r => r.id === routeId)).filter(r => r);
                let dayDistance = 0;
                let dayElevationGain = 0;
                let dayMinEle = Infinity;
                let dayMaxEle = -Infinity;
                
                dayRoutes.forEach(route => {
                    if (route.stats) {
                        dayDistance += parseFloat(route.stats.distance);
                        dayElevationGain += route.stats.elevationGain || 0;
                        if (route.stats.minEle !== null) {
                            dayMinEle = Math.min(dayMinEle, route.stats.minEle);
                            dayMaxEle = Math.max(dayMaxEle, route.stats.maxEle);
                        }
                    }
                });
                
                if (statsDiv) {
                    if (dayRoutes.length > 0) {
                        let statsText = `${dayDistance.toFixed(1)} km`;
                        if (dayElevationGain > 0) {
                            statsText += ` | ‚¨ÜÔ∏è ${dayElevationGain} m`;
                        }
                        if (dayMinEle !== Infinity) {
                            statsText += ` | üèîÔ∏è ${dayMinEle}-${dayMaxEle}m`;
                        }
                        
                        // Calculate overlap for this day if 2 routes
                        if (dayRoutes.length === 2) {
                            const dayRouteCoords = dayRoutes.map(route => {
                                return route.polyline.getLatLngs().map(ll => ({ lat: ll.lat, lng: ll.lng }));
                            });
                            
                            const tolerance = 0.0005;
                            let overlapPoints = 0, totalComparisons = 0;
                            const coords1 = dayRouteCoords[0];
                            const coords2 = dayRouteCoords[1];
                            
                            for (let i = 0; i < coords1.length - 1; i++) {
                                const seg1Start = coords1[i];
                                const seg1End = coords1[i + 1];
                                const dir1 = { lat: seg1End.lat - seg1Start.lat, lng: seg1End.lng - seg1Start.lng };
                                
                                for (let j = 0; j < coords2.length - 1; j++) {
                                    const seg2Start = coords2[j];
                                    const seg2End = coords2[j + 1];
                                    const dist = Math.sqrt(
                                        Math.pow(seg1Start.lat - seg2Start.lat, 2) + 
                                        Math.pow(seg1Start.lng - seg2Start.lng, 2)
                                    );
                                    if (dist < tolerance) {
                                        const dir2 = { lat: seg2End.lat - seg2Start.lat, lng: seg2End.lng - seg2Start.lng };
                                        const dotProduct = dir1.lat * dir2.lat + dir1.lng * dir2.lng;
                                        if (dotProduct > 0) {
                                            overlapPoints++;
                                            break;
                                        }
                                    }
                                }
                            }
                            totalComparisons = coords1.length;
                            
                            const overlapPercentage = totalComparisons > 0 ? (overlapPoints / totalComparisons * 100) : 0;
                            if (overlapPercentage > 0) {
                                statsText += ` | üîó ${overlapPercentage.toFixed(1)}%`;
                            }
                        }
                        
                        statsDiv.textContent = statsText;
                    } else {
                        statsDiv.textContent = '';
                    }
                }
                
                // Update toggle button text
                if (toggleBtn) {
                    if (day.visible) {
                        toggleBtn.textContent = 'Skjul dag';
                        toggleBtn.classList.remove('hidden');
                    } else {
                        toggleBtn.textContent = 'Vis dag';
                        toggleBtn.classList.add('hidden');
                    }
                }
                
                let html = '';
                
                dayRoutes.forEach(route => {
                    html += `
                        <div class="day-route-item" 
                             style="border-left-color: ${route.color};">
                            <span class="remove-from-day" onclick="removeFromDay(${route.id}, ${day.id})">‚úï</span>
                            <div class="day-route-name">${route.fileName}</div>
                            <div class="day-route-stats">
                                ${route.stats ? route.stats.distance + ' km' : ''}
                                ${route.stats && route.stats.elevationGain ? ' | ‚¨ÜÔ∏è ' + route.stats.elevationGain + ' m' : ''}
                            </div>
                        </div>
                    `;
                });
                
                contentDiv.innerHTML = html;
            });
        }

        window.toggleDaysExpand = function() {
            const content = document.getElementById('daysContent');
            const toggle = document.querySelector('.days-toggle');
            
            if (content.classList.contains('collapsed')) {
                content.classList.remove('collapsed');
                toggle.textContent = '‚ñº';
            } else {
                content.classList.add('collapsed');
                toggle.textContent = '‚ñ∂';
            }
        };

        function getProgressElements() {
            return {
                progressContainer: document.getElementById('splashScreen'),
                progressFill: document.getElementById('splashProgressFill'),
                progressText: document.getElementById('splashText')
            };
        }

        async function addRouteFromGpxContent(fileName, gpxContent, index, total, progressText, progressFill, showAlerts = true, isBundled = false) {
            try {
                const points = parseGPX(gpxContent);
                if (points.length === 0) {
                    if (showAlerts) {
                        alert(`Ingen GPS-punkter funnet i ${fileName}`);
                    }
                    return;
                }

                const hasElevation = points.some(p => p.ele !== null);
                if (!hasElevation) {
                    progressText.textContent = `${index + 1} av ${total} - Henter h√∏ydedata for ${fileName}...`;
                    await enrichWithElevation(points);
                }

                progressText.textContent = `${index + 1} av ${total} - Legger til ${fileName} p√• kartet...`;
                const color = colors[routes.length % colors.length];
                addRoute(fileName, points, color, isBundled);
            } catch (error) {
                console.error(`Feil ved parsing av ${fileName}:`, error);
                if (showAlerts) {
                    alert(`Kunne ikke lese ${fileName}. Sjekk at det er en gyldig GPX-fil.`);
                }
            } finally {
                progressFill.style.width = `${((index + 1) / total) * 100}%`;
            }
        }

        function readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (event) => resolve(event.target.result);
                reader.onerror = () => reject(new Error(`Kunne ikke lese filen ${file.name}`));
                reader.readAsText(file);
            });
        }

        async function loadBundledRoutes() {
            if (bundledRouteFiles.length === 0) return;

            const { progressContainer, progressFill, progressText } = getProgressElements();
            progressContainer.classList.add('active');
            progressFill.style.width = '0%';

            for (let i = 0; i < bundledRouteFiles.length; i++) {
                const fileName = bundledRouteFiles[i];
                progressText.textContent = `${i + 1} av ${bundledRouteFiles.length} - Laster ${fileName}...`;

                try {
                    const encodedFileName = fileName.split('/').map(encodeURIComponent).join('/');
                    const response = await fetch(`routes/${encodedFileName}`);
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    const gpxContent = await response.text();
                    await addRouteFromGpxContent(
                        fileName,
                        gpxContent,
                        i,
                        bundledRouteFiles.length,
                        progressText,
                        progressFill,
                        false,
                        true // Mark as bundled
                    );
                } catch (error) {
                    console.error(`Kunne ikke laste ${fileName}:`, error);
                    progressFill.style.width = `${((i + 1) / bundledRouteFiles.length) * 100}%`;
                }
            }

            progressText.textContent = `Ferdig! ${bundledRouteFiles.length} standardfiler lastet.`;
            setTimeout(() => {
                const splashScreen = document.getElementById('splashScreen');
                splashScreen.classList.add('minimized');
            }, 500);
        }

        document.getElementById('gpxInput').addEventListener('change', async (e) => {
            const files = Array.from(e.target.files);
            if (files.length === 0) return;

            const { progressContainer, progressFill, progressText } = getProgressElements();
            
            progressContainer.classList.remove('minimized');
            progressFill.style.width = '0%';

            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                progressText.textContent = `${i + 1} av ${files.length} - Leser ${file.name}...`;
                try {
                    const gpxContent = await readFileAsText(file);
                    await addRouteFromGpxContent(
                        file.name,
                        gpxContent,
                        i,
                        files.length,
                        progressText,
                        progressFill,
                        true,
                        false // User uploaded
                    );
                } catch (error) {
                    console.error(`Kunne ikke lese ${file.name}:`, error);
                    alert(`Kunne ikke lese ${file.name}.`);
                    progressFill.style.width = `${((i + 1) / files.length) * 100}%`;
                }
            }

            progressText.textContent = `Ferdig! ${files.length} filer lastet.`;
            setTimeout(() => {
                progressContainer.classList.add('minimized');
            }, 500);
            e.target.value = '';
        });

        window.toggleDayVisibility = function(dayId) {
            const day = days.find(d => d.id === dayId);
            if (!day) return;
            
            day.visible = !day.visible;
            
            day.routes.forEach(routeId => {
                const route = routes.find(r => r.id === routeId);
                if (route) {
                    route.visible = day.visible;
                    if (day.visible) {
                        route.polyline.addTo(map);
                        route.startMarker.addTo(map);
                        route.endMarker.addTo(map);
                    } else {
                        route.polyline.remove();
                        route.startMarker.remove();
                        route.endMarker.remove();
                    }
                }
            });
            
            updateSidebar();
        };

        document.getElementById('toggleMapBtn').addEventListener('click', toggleMapBackground);
        document.getElementById('hideAllBtn').addEventListener('click', hideAllRoutes);
        document.getElementById('showAllBtn').addEventListener('click', showAllRoutes);

        document.getElementById('clearBtn').addEventListener('click', () => {
            if (routes.length === 0) return;
            
            if (confirm('Er du sikker p√• at du vil fjerne alle ruter?')) {
                routes.forEach(route => {
                    route.polyline.remove();
                    route.startMarker.remove();
                    route.endMarker.remove();
                });
                
                routes.length = 0;
                
                days.forEach(day => {
                    day.routes = [];
                    day.visible = true;
                });
                
                updateSidebar();
                map.setView([60.472, 8.4689], 6);
            }
        });

        window.toggleRoute = toggleRoute;

        window.removeRoute = function(routeId) {
            const route = routes.find(r => r.id === routeId);
            if (!route) return;
            
            if (confirm(`Fjerne "${route.fileName}"?`)) {
                route.polyline.remove();
                route.startMarker.remove();
                route.endMarker.remove();
                
                days.forEach(day => {
                    day.routes = day.routes.filter(id => id !== routeId);
                });
                
                const index = routes.findIndex(r => r.id === routeId);
                if (index !== -1) {
                    routes.splice(index, 1);
                }
                
                updateRouteColors();
                updateSidebar();
            }
        };

        // Drag and drop
        let draggedRouteId = null;
        let draggedFromDayId = null;

        window.dragStart = function(event, routeId) {
            draggedRouteId = routeId;
            draggedFromDayId = null;
            event.target.classList.add('dragging');
        };

        window.allowDrop = function(event) {
            event.preventDefault();
            event.currentTarget.classList.add('drag-over');
        };

        window.dragLeave = function(event) {
            event.currentTarget.classList.remove('drag-over');
        };

        window.dropOnDay = function(event) {
            event.preventDefault();
            event.currentTarget.classList.remove('drag-over');
            
            const dayId = parseInt(event.currentTarget.dataset.dayId);
            const day = days.find(d => d.id === dayId);
            
            if (!day || draggedRouteId === null) return;
            
            // If dragging from another day, remove from that day
            if (draggedFromDayId !== null) {
                const oldDay = days.find(d => d.id === draggedFromDayId);
                if (oldDay) {
                    oldDay.routes = oldDay.routes.filter(id => id !== draggedRouteId);
                }
            }
            
            // Smart auto-replace: if 2 routes already there, remove the oldest one
            if (!day.routes.includes(draggedRouteId)) {
                if (day.routes.length >= 2) {
                    // Remove first route (oldest)
                    day.routes.shift();
                }
                day.routes.push(draggedRouteId);
                
                // Hide all routes first
                routes.forEach(route => {
                    route.visible = false;
                    route.polyline.remove();
                    route.startMarker.remove();
                    route.endMarker.remove();
                });
                
                // Show only routes in VISIBLE days
                days.forEach(d => {
                    if (d.visible) {
                        d.routes.forEach(routeId => {
                            const route = routes.find(r => r.id === routeId);
                            if (route) {
                                route.visible = true;
                                route.polyline.addTo(map);
                                route.startMarker.addTo(map);
                                route.endMarker.addTo(map);
                            }
                        });
                    }
                });
            }
            
            draggedRouteId = null;
            draggedFromDayId = null;
            
            updateRouteColors();
            updateSidebar();
        };

        window.removeFromDay = function(routeId, dayId) {
            const day = days.find(d => d.id === dayId);
            if (day) {
                day.routes = day.routes.filter(id => id !== routeId);
                updateRouteColors();
                updateSidebar();
            }
        };

        window.downloadDayGPX = function(dayId) {
            const day = days.find(d => d.id === dayId);
            if (!day || day.routes.length === 0) {
                alert('Ingen ruter valgt for denne dagen!');
                return;
            }

            const dayRoutes = day.routes.map(routeId => routes.find(r => r.id === routeId)).filter(r => r);
            
            if (!dayRoutes[0] || !dayRoutes[0].gpxPoints) {
                alert('GPX-punkter mangler for rutene.');
                return;
            }

            let allPoints = [];
            dayRoutes.forEach(route => {
                if (route.gpxPoints) {
                    allPoints = allPoints.concat(route.gpxPoints);
                }
            });

            let gpxContent = `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="G√•pings Mallorca Getaway" xmlns="http://www.topografix.com/GPX/1/1">
  <metadata>
    <name>Dag ${dayId} - ${dayRoutes.map(r => r.fileName).join(' + ')}</name>
  </metadata>
  <trk>
    <name>Dag ${dayId}</name>
    <trkseg>
`;
            
            allPoints.forEach(point => {
                gpxContent += `      <trkpt lat="${point.lat}" lon="${point.lon}">`;
                if (point.ele !== null && point.ele !== undefined) {
                    gpxContent += `<ele>${point.ele}</ele>`;
                }
                gpxContent += `</trkpt>
`;
            });
            
            gpxContent += `    </trkseg>
  </trk>
</gpx>`;
            
            const blob = new Blob([gpxContent], { type: 'application/gpx+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `Dag_${dayId}_Mallorca.gpx`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        };

        window.autoMakeElite = function() {
            days.forEach(day => day.routes = []);
            
            for (let dayNum = 1; dayNum <= 4; dayNum++) {
                const day = days.find(d => d.id === dayNum);
                if (!day) continue;
                
                const dayARoutes = routes.filter(r => {
                    if (!r.isBundled) return false;
                    const match = r.fileName.match(/GGTM26_D(\d+)_A_/);
                    if (!match || parseInt(match[1]) !== dayNum) return false;
                    const afterA = r.fileName.split('_A_')[1];
                    return afterA && !afterA.match(/^[12]/);
                });
                
                if (dayARoutes.length >= 2) {
                    const utRoute = dayARoutes.find(r => r.fileName.includes('Helios_'));
                    const hjemRoute = dayARoutes.find(r => !r.fileName.includes('Helios_') && r.fileName.includes('_Helios'));
                    
                    if (utRoute && hjemRoute) {
                        day.routes.push(utRoute.id, hjemRoute.id);
                    } else {
                        dayARoutes.slice(0, 2).forEach(route => day.routes.push(route.id));
                    }
                }
            }
            
            updateRouteColors();
            updateSidebar();
            alert('‚úÖ Elite (A) ruter lastet for alle 4 dager!');
        };

        window.autoMakeMosjonist = function() {
            days.forEach(day => day.routes = []);
            
            for (let dayNum = 1; dayNum <= 4; dayNum++) {
                const day = days.find(d => d.id === dayNum);
                if (!day) continue;
                
                const dayBRoutes = routes.filter(r => {
                    if (!r.isBundled) return false;
                    const match = r.fileName.match(/GGTM26_D(\d+)_B_/);
                    if (!match || parseInt(match[1]) !== dayNum) return false;
                    const afterB = r.fileName.split('_B_')[1];
                    return afterB && !afterB.match(/^[12]/);
                });
                
                if (dayBRoutes.length >= 2) {
                    const utRoute = dayBRoutes.find(r => r.fileName.includes('Helios_'));
                    const hjemRoute = dayBRoutes.find(r => !r.fileName.includes('Helios_') && r.fileName.includes('_Helios'));
                    
                    if (utRoute && hjemRoute) {
                        day.routes.push(utRoute.id, hjemRoute.id);
                    } else {
                        dayBRoutes.slice(0, 2).forEach(route => day.routes.push(route.id));
                    }
                } else {
                    const b1Route = routes.find(r => r.isBundled && r.fileName.includes(`GGTM26_D${dayNum}_B1_`));
                    const b2Route = routes.find(r => r.isBundled && r.fileName.includes(`GGTM26_D${dayNum}_B2_`));
                    
                    if (b1Route && b2Route) {
                        day.routes.push(b1Route.id, b2Route.id);
                    }
                }
            }
            
            updateRouteColors();
            updateSidebar();
            alert('‚úÖ Mosjonist (B) ruter lastet for alle 4 dager!');
        };

        // Initialize
        updateSidebar();
        loadBundledRoutes();
    </script>

    <!-- SoundCloud Embed -->
    <div id="soundcloud-player" style="position: fixed; bottom: 20px; left: 180px; z-index: 10000; background: rgba(20, 20, 40, 0.95); border-radius: 8px; padding: 6px; box-shadow: 0 2px 12px rgba(0,0,0,0.4); display: none;"></div>
    
    <!-- Elevation Profile -->
    <div id="elevationProfile" class="elevation-profile">
        <div class="elevation-profile-header">
            <span id="profileTitle">L√∏ypeprofil</span>
            <span class="elevation-profile-close" onclick="closeElevationProfile()">‚úï</span>
        </div>
        <canvas id="profileCanvas" class="elevation-profile-canvas"></canvas>
    </div>
    
    <script>
    // SoundCloud Player - Direct iframe (no oEmbed to avoid CORS)
    (function() {
        window.toggleSCPlayer = function() {
            const player = document.getElementById('soundcloud-player');
            const isHidden = player.style.display === 'none';

            if (isHidden) {
                player.style.display = 'block';
                if (!player.hasChildNodes()) {
                    const iframe = document.createElement('iframe');
                    iframe.width = '300';
                    iframe.height = '80';
                    iframe.scrolling = 'no';
                    iframe.frameborder = 'no';
                    iframe.allow = 'autoplay';
                    iframe.src = 'https://w.soundcloud.com/player/?url=https%3A//soundcloud.com/mrkrokett/looks-like-love-rayko-super-disco-rework-low-quality-4&color=%23ff5500&auto_play=true&hide_related=true&show_comments=false&show_user=false&show_reposts=false&show_teaser=false&visual=true';
                    player.appendChild(iframe);
                }
            } else {
                player.style.display = 'none';
            }
        };
    })();
    
    // Elevation Profile Functions
    window.closeElevationProfile = function() {
        document.getElementById('elevationProfile').classList.remove('visible');
    };
    
   window.showElevationProfile = function(dayId) {
    const profile = document.getElementById('elevationProfile');
    const canvas = document.getElementById('profileCanvas');
    const ctx = canvas.getContext('2d');
    const title = document.getElementById('profileTitle');

    profile.classList.add('visible');

    requestAnimationFrame(() => {
        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;

        const day = days.find(d => d.id === dayId);
        if (!day || day.routes.length === 0) return;

        const dayRoutes = day.routes
            .map(id => routes.find(r => r.id === id))
            .filter(r => r && r.gpxPoints);
        if (dayRoutes.length === 0) return;

        let allPoints = [];
        dayRoutes.forEach(r => allPoints = allPoints.concat(r.gpxPoints));
        const points = allPoints.filter(p => typeof p.ele === 'number');
        if (points.length < 2) return;

        // --- Kumulativ distanse ---
        let cumulativeDistance = [0];
        for (let i = 1; i < points.length; i++) {
            const p1 = points[i-1], p2 = points[i];
            const R = 6371000;
            const œÜ1 = p1.lat*Math.PI/180;
            const œÜ2 = p2.lat*Math.PI/180;
            const ŒîœÜ = (p2.lat-p1.lat)*Math.PI/180;
            const ŒîŒª = (p2.lon-p1.lon)*Math.PI/180;
            const a = Math.sin(ŒîœÜ/2)**2 + Math.cos(œÜ1)*Math.cos(œÜ2)*Math.sin(ŒîŒª/2)**2;
            const c = 2*Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            cumulativeDistance.push(cumulativeDistance[i-1] + R*c);
        }

        const totalDistance = cumulativeDistance[cumulativeDistance.length-1];
        const elevations = points.map(p => p.ele);
        const minEle = Math.min(...elevations);
        const maxEle = Math.max(...elevations);

        const dayNames = ['Port de Soller','Cap de Formentor','Sa Calobra','Puig Major'];
        const dayName = dayNames[dayId-1]||'';
        title.textContent = `L√∏ypeprofil - Dag ${dayId}${dayName ? ` (${dayName})` : ''}`;

        // --- Smooth kurve ---
        function smoothElevs(arr, windowSize=7){
            return arr.map((v,i)=>{
                const start = Math.max(0,i-Math.floor(windowSize/2));
                const end = Math.min(arr.length,i+Math.floor(windowSize/2)+1);
                return arr.slice(start,end).reduce((a,b)=>a+b,0)/(end-start);
            });
        }
        const smoothE = smoothElevs(elevations,7);
        
        function findPeaks(elev, dist) {
            const W = 4;            // hvor mange punkter vi ser p√• hver side
            const MIN_DISTANCE = 8000; // meter mellom topper (unng√• samme fjell)
            const MAX_PEAKS = 5;    // antall topper du vil ha

            let candidates = [];

            // 1Ô∏è‚É£ Finn alle lokale maks
            for (let i = W; i < elev.length - W; i++) {
                const current = elev[i];
                const before = Math.max(...elev.slice(i - W, i));
                const after  = Math.max(...elev.slice(i + 1, i + W + 1));

                if (current >= before && current >= after) {
                    candidates.push({
                        index: i,
                        elevation: current,
                        distance: dist[i]
                    });
                }
            }

            // 2Ô∏è‚É£ Sorter etter h√∏yde (h√∏yest f√∏rst)
            candidates.sort((a, b) => b.elevation - a.elevation);

            // 3Ô∏è‚É£ Fjern topper som ligger for tett (samme fjell)
            const selected = [];

            for (let peak of candidates) {
                const tooClose = selected.some(s =>
                    Math.abs(s.distance - peak.distance) < MIN_DISTANCE
                );

                if (!tooClose) {
                    selected.push(peak);
                }

                if (selected.length >= MAX_PEAKS) break;
            }

            // 4Ô∏è‚É£ Returner bare indeksene
            return selected.map(p => p.index);
        }


        /* --- Finn topper ---
        function findPeaks(elev, dist){
            const peaks = [];
            const MIN_H=12, MIN_D=250, W=3;
            let lastDist=-Infinity;
            for(let i=W;i<elev.length-W;i++){
                const c=elev[i];
                const b=Math.max(...elev.slice(i-W,i));
                const a=Math.max(...elev.slice(i+1,i+W+1));
                if(c>b && c>a && (c-Math.min(b,a))>MIN_H && (dist[i]-lastDist)>MIN_D){
                    peaks.push(i);
                    lastDist=dist[i];
                }
            }
            return peaks;
        }
       function findPeaks(elev, dist) {
    const peaks = [];
    const W = 3; // window for √• sjekke lokal maks

    for (let i = W; i < elev.length - W; i++) {
        const current = elev[i];
        const before = Math.max(...elev.slice(i - W, i));
        const after  = Math.max(...elev.slice(i + 1, i + W + 1));

        if (current >= before && current >= after) {
            peaks.push(i);
        }
    }

    return peaks;
}*/


        const peakIdx = findPeaks(smoothE, cumulativeDistance);

        // --- Peak koordinater med trigger ---
        const peaks = peakIdx.map(i=>({
            x: cumulativeDistance[i]/totalDistance*canvas.width,
            y: canvas.height - ((smoothE[i]-minEle)/(maxEle-minEle))*(canvas.height-20),
            life:0,
            triggered:false
        }));

        // Lyd
        const starSound = new Audio('https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg');

        let start=null;
        const animDur=1200;

        function animate(ts){
            if(!start) start=ts;
            const elapsed = ts-start;
            const progress = Math.min(elapsed/animDur,1);
            const maxX = progress*canvas.width;

            ctx.clearRect(0,0,canvas.width,canvas.height);

            // --- Bakgrunn og grid ---
            ctx.fillStyle='rgba(0,0,0,0.3)';ctx.fillRect(0,0,canvas.width,canvas.height);
            ctx.strokeStyle='rgba(0,245,255,0.2)';ctx.lineWidth=1;
            for(let i=0;i<=5;i++){const y=(canvas.height/5)*i;ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(canvas.width,y);ctx.stroke();}

            // --- Smooth Bezier kurve ---
            ctx.beginPath();ctx.strokeStyle='#00f5ff';ctx.lineWidth=2;
            let x0 = cumulativeDistance[0]/totalDistance*canvas.width;
            let y0 = canvas.height - ((smoothE[0]-minEle)/(maxEle-minEle))*(canvas.height-20);
            ctx.moveTo(x0,y0);
            for(let i=1;i<smoothE.length;i++){
                const x1 = cumulativeDistance[i]/totalDistance*canvas.width;
                const y1 = canvas.height - ((smoothE[i]-minEle)/(maxEle-minEle))*(canvas.height-20);
                if(x1>maxX) break;
                const cx=(x0+x1)/2, cy=(y0+y1)/2;
                ctx.quadraticCurveTo(x0,y0,cx,cy);
                x0=x1; y0=y1;
            }
            ctx.stroke();

            // --- Stjerner ---
            for(let i=peaks.length-1;i>=0;i--){
                const s=peaks[i];
                if(!s.triggered && maxX>=s.x){
                    s.triggered=true;
                    starSound.play().catch(()=>{});
                }
                if(s.triggered){
                    s.life+=0.02;
                    const rise = s.life*40;
                    const op = 1-s.life;
                    if(op<=0){peaks.splice(i,1); continue;}
                    ctx.save(); ctx.globalAlpha = op;
                    drawStar(ctx, s.x, s.y - rise, 5, 8, 4); // <-- din eksisterende funksjon
                    ctx.restore();
                }
            }

            // --- Labels ---
            ctx.fillStyle='#00f5ff';ctx.font='11px Courier New';
            ctx.fillText(`${minEle.toFixed(0)}m`,5,canvas.height-5);
            ctx.fillText(`${maxEle.toFixed(0)}m`,5,15);
            ctx.fillText(`${(totalDistance/1000).toFixed(1)}km`,canvas.width-60,canvas.height-5);

            if(progress<1 || peaks.length>0) requestAnimationFrame(animate);
        }

        requestAnimationFrame(animate);
    });
};



    function drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {

        let rot = Math.PI / 2 * 3;
        let x = cx;
        let y = cy;
        const step = Math.PI / spikes;

        ctx.beginPath();
        ctx.moveTo(cx, cy - outerRadius);

        for (let i = 0; i < spikes; i++) {
            x = cx + Math.cos(rot) * outerRadius;
            y = cy + Math.sin(rot) * outerRadius;
            ctx.lineTo(x, y);
            rot += step;

            x = cx + Math.cos(rot) * innerRadius;
            y = cy + Math.sin(rot) * innerRadius;
            ctx.lineTo(x, y);
            rot += step;
        }

        ctx.lineTo(cx, cy - outerRadius);
        ctx.closePath();

        ctx.fillStyle = '#ffd700';
        ctx.fill();
    };
    // Konfetti-funksjon
    function triggerConfetti() {
        const container = document.getElementById('confetti-container');
        const numConfetti = 50; // flere biter

        for (let i = 0; i < numConfetti; i++) {
            const confetti = document.createElement('div');
            confetti.classList.add('confetti');

            // tilfeldig farge
            confetti.style.backgroundColor = `hsl(${Math.random() * 360}, 80%, 60%)`;

            // startposisjon (midten av skjermen / kan justeres til badge)
            confetti.style.left = `${window.innerWidth / 2}px`;
            confetti.style.top = `${window.innerHeight / 3}px`;

            // tilfeldig retning og avstand
            const x = (Math.random() - 0.5) * 400; // -200 til +200 px
            const y = (Math.random() - 0.5) * 300; // -150 til +150 px
            confetti.style.setProperty('--x', `${x}px`);
            confetti.style.setProperty('--y', `${y}px`);

            // tilfeldig st√∏rrelse
            const size = 8 + Math.random() * 8;
            confetti.style.width = `${size}px`;
            confetti.style.height = `${size}px`;

            // legg til i container
            container.appendChild(confetti);

            // fjern etter animasjon
            setTimeout(() => container.removeChild(confetti), 1500);
        }
    }





    </script>
    <div id="confetti-container"></div>

</body>
</html>