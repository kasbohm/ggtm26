<!DOCTYPE html>
<html lang="no">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>G√•pings Mallorca - Mobile</title>
    
    <!-- Open Graph -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://kasbohm.github.io/ggtm26/mobile.html">
    <meta property="og:title" content="G√•pings Mallorca Getaway 2026 - Mobile">
    <meta property="og:description" content="Velg dine ruter, planlegg dagene og gj√∏r deg klar for en episk G√•pingtur p√• Mallorca i 2026! Elite eller mosjonist, eller kombiner!">
    <meta property="og:image" content="https://kasbohm.github.io/ggtm26/logo.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://kasbohm.github.io/ggtm26/mobile.html">
    <meta property="twitter:title" content="G√•pings Mallorca Getaway 2026">
    <meta property="twitter:description" content="Velg dine ruter, planlegg dagene og gj√∏r deg klar for en episk G√•pingtur p√• Mallorca i 2026! Elite eller mosjonist, eller kombiner!">
    <meta property="twitter:image" content="https://kasbohm.github.io/ggtm26/logo.png">
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Courier New', monospace; 
            height: 100vh; 
            overflow: hidden;
            background: linear-gradient(180deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
        }
        
        /* Splash */
        .splash { position: fixed; inset: 0; background: black; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 9999; transition: opacity 0.5s; padding: 20px; }
        .splash.hidden { opacity: 0; pointer-events: none; }
        .splash img { width: 95%; max-width: 600px; height: auto; }
        .splash-bar { width: 85%; max-width: 500px; height: 12px; background: rgba(255,255,255,0.2); border-radius: 10px; margin-top: 3rem; overflow: hidden; }
        .splash-fill { height: 100%; background: linear-gradient(90deg, #00f5ff, #ff00ff, #ffaa00); background-size: 200%; animation: shimmer 2s linear infinite; transition: width 0.3s; }
        @keyframes shimmer { 0% { background-position: 200% 0; } 100% { background-position: -200% 0; } }
        .splash-text { color: #00f5ff; font-size: 1rem; margin-top: 1.5rem; text-shadow: 0 0 10px rgba(0,245,255,0.8); text-align: center; padding: 0 20px; }
        
        /* Menu */
        .menu-btn { position: fixed; top: 10px; right: 10px; z-index: 2000; width: 50px; height: 50px; background: linear-gradient(135deg, #ff00ff, #ff0080); border-radius: 50%; display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 5px; cursor: pointer; box-shadow: 0 4px 15px rgba(255,0,255,0.6); border: 2px solid #ff00ff; }
        .menu-btn span { width: 25px; height: 3px; background: white; transition: 0.3s; box-shadow: 0 0 5px rgba(255,255,255,0.8); }
        
        .menu { position: fixed; top: 0; right: -100%; width: 280px; height: 100vh; background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%); z-index: 1999; transition: right 0.3s; padding: 70px 20px 20px; overflow-y: auto; border-left: 2px solid #00f5ff; box-shadow: -4px 0 20px rgba(0,245,255,0.3); }
        .menu.active { right: 0; }
        .menu-item { background: linear-gradient(135deg, #302b63, #24243e); color: #00f5ff; padding: 15px; margin-bottom: 10px; border-radius: 8px; border: 2px solid #00f5ff; width: 100%; font-size: 1rem; cursor: pointer; display: flex; align-items: center; gap: 10px; font-weight: 700; box-shadow: 0 4px 10px rgba(0,245,255,0.3); transition: all 0.3s; }
        .menu-item:active { transform: scale(0.95); box-shadow: 0 6px 15px rgba(0,245,255,0.5); }
        
        /* Map */
        #map { position: absolute; top: 0; left: 0; right: 0; bottom: 250px; z-index: 1; }
        
        /* Day Swiper */
        .day-swiper { position: fixed; bottom: 0; left: 0; right: 0; height: 280px; background: linear-gradient(180deg, rgba(26,26,46,0.95) 0%, rgba(22,33,62,0.98) 100%); box-shadow: 0 -4px 20px rgba(255,0,255,0.3); border-top: 2px solid #ff00ff; z-index: 1000; overflow: hidden; }
        .day-cards { display: flex; height: 100%; transition: transform 0.3s; }
        .day-card { min-width: 100%; padding: 15px; display: flex; flex-direction: column; }
        .day-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .day-title { font-weight: 700; font-size: 1.2rem; color: #00f5ff; text-shadow: 0 0 10px rgba(0,245,255,0.8); }
        .day-stats { font-size: 0.95rem; color: #ffaa00; text-shadow: 0 0 5px rgba(255,170,0,0.6); }
        .day-select-btn { background: linear-gradient(135deg, #ffaa00, #ff8800); border: 2px solid #ffaa00; color: #0a0a0a; padding: 8px 16px; border-radius: 20px; font-size: 0.85rem; font-weight: 700; cursor: pointer; box-shadow: 0 2px 8px rgba(255,170,0,0.4); }
        .day-buttons { display: flex; gap: 5px; }
        .profile-btn { background: linear-gradient(135deg, #00f5ff, #0080ff); border: 2px solid #00f5ff; color: #0a0a0a; padding: 8px 12px; border-radius: 20px; font-size: 0.85rem; font-weight: 700; cursor: pointer; box-shadow: 0 2px 8px rgba(0,245,255,0.4); }
        .day-routes { display: flex; gap: 8px; overflow-x: auto; flex: 1; margin-top: 8px; }
        /* Route timeline (Legs) */
.route-timeline {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.route-leg {
  display: flex;
  gap: 10px;
  padding: 10px 12px;
  background: rgba(255,255,255,0.05);
  border-left: 4px solid;
  border-radius: 6px;
}

.route-leg-index {
  font-weight: 900;
  font-size: 1rem;
  color: #ffaa00;
  min-width: 22px;
  text-align: center;
}

.route-leg-content {
  flex: 1;
}

.route-leg-name {
  font-size: 0.85rem;
  font-weight: 700;
  color: #00f5ff;
  margin-bottom: 2px;
}

.route-leg-stats {
  font-size: 0.75rem;
  color: #ffaa00;
}
.route-connector {
  height: 14px;
  margin-left: 21px;
  border-left: 2px dotted rgba(255,255,255,0.25);
}

        .route-chip { padding: 10px 14px; background: linear-gradient(135deg, rgba(48,43,99,0.8), rgba(36,36,62,0.8)); border-radius: 20px; font-size: 0.8rem; white-space: nowrap; border-left: 3px solid; color: white; box-shadow: 0 2px 8px rgba(0,0,0,0.4); }
        .day-dots { display: flex; justify-content: center; gap: 8px; position: absolute; bottom: 8px; left: 50%; transform: translateX(-50%); z-index: 10; }
        .dot { width: 24px; height: 24px; background: rgba(189,195,199,0.3); border-radius: 50%; border: 2px solid #00f5ff; cursor: pointer; transition: all 0.3s; display: flex; align-items: center; justify-content: center; font-size: 0.7rem; color: rgba(255,255,255,0.5); font-weight: 700; }
        .dot.active { background: #00f5ff; box-shadow: 0 0 10px rgba(0,245,255,0.8); transform: scale(1.2); color: #0a0a0a; }
        
        /* FAB */
        .fab-group { position: fixed; bottom: 280px; right: 15px; display: flex; flex-direction: column; gap: 10px; z-index: 2001; }
        .fab { width: 56px; height: 56px; background: linear-gradient(135deg, #00f5ff, #0080ff); border-radius: 50%; border: 2px solid #00f5ff; color: #0a0a0a; font-size: 1.5rem; font-weight: 900; box-shadow: 0 4px 15px rgba(0,245,255,0.6); cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.3s; }
        .fab:active { transform: scale(0.9); }
        .fab.select { background: linear-gradient(135deg, #ffaa00, #ff8800); border-color: #ffaa00; box-shadow: 0 4px 15px rgba(255,170,0,0.6); }
        .fab.download { background: linear-gradient(135deg, #00ff88, #00cc66); border-color: #00ff88; box-shadow: 0 4px 15px rgba(0,255,136,0.6); }
        
        /* Route Selector Modal */
        .modal { position: fixed; inset: 0; background: rgba(0,0,0,0.9); z-index: 3000; display: none; align-items: center; justify-content: center; }
        .modal.active { display: flex; }
        .modal-content { background: linear-gradient(180deg, #1a1a2e, #16213e); border: 2px solid #00f5ff; border-radius: 12px; max-width: 90%; max-height: 80vh; overflow-y: auto; padding: 20px; box-shadow: 0 0 40px rgba(0,245,255,0.5); }
        .modal-header { color: #00f5ff; font-size: 1.3rem; font-weight: 700; margin-bottom: 15px; text-shadow: 0 0 10px rgba(0,245,255,0.8); text-align: center; }
        .route-selector { display: flex; flex-direction: column; gap: 10px; }
        .route-option { display: flex; align-items: flex-start; gap: 10px; padding: 12px; background: rgba(48,43,99,0.5); border: 2px solid transparent; border-radius: 8px; cursor: pointer; transition: all 0.3s; }
        .route-option.selected { background: rgba(0,245,255,0.2); border-color: #00f5ff; box-shadow: 0 0 15px rgba(0,245,255,0.4); }
        .route-option input[type="checkbox"] { width: 20px; height: 20px; margin-top: 2px; accent-color: #00f5ff; flex-shrink: 0; }
        .route-option label { position: relative; flex: 1; color: white; font-size: 0.85rem; cursor: pointer; }
        .route-name { font-weight: 700; color: #00f5ff; margin-bottom: 4px; }
        .route-details { font-size: 0.75rem; color: #ffaa00; }
        .modal-actions { display: flex; gap: 10px; margin-top: 15px; }
        .modal-btn { flex: 1; padding: 12px; border-radius: 8px; border: 2px solid; font-weight: 700; cursor: pointer; transition: all 0.3s; }
        .modal-btn.save { background: linear-gradient(135deg, #00ff88, #00cc66); border-color: #00ff88; color: #0a0a0a; }
        .modal-btn.cancel { background: transparent; border-color: #ff0080; color: #ff0080; }
   
        .route-badge {
            position: absolute;
            top: 10px;
            max-width: 5rem;
            text-align: center;
            right: -30px;
            background: gold;
            color: black;
            font-weight: bold;
            padding: 3px 8px;
            border-radius: 5px;
            transform: rotate(15deg);
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            font-size: 0.75rem;
        }

        .route-badge.best {
            background: #28a745; /* gr√∏nn */
            color: white;
        }

        .route-badge.worst {
            background: #ffc107; /* gul */
            color: black;
        }
        #confetti-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: visible;
            z-index: 9999;
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            opacity: 0.9;
            border-radius: 2px;
            animation: explode 1.5s forwards;
        }

        @keyframes explode {
            0% {
                transform: translate(0, 0) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translate(var(--x), var(--y)) rotate(720deg);
                opacity: 0;
            }
        }

        /* Elevation Profile Modal */
        .elevation-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.95); z-index: 3001; display: none; align-items: center; justify-content: center; padding: 20px; }
        .elevation-modal.active { display: flex; }
        .elevation-content { background: linear-gradient(180deg, #1a1a2e, #16213e); border: 2px solid #00f5ff; border-radius: 12px; width: 100%; max-width: 500px; padding: 15px; box-shadow: 0 0 40px rgba(0,245,255,0.5); }
        .elevation-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .elevation-title { color: #00f5ff; font-size: 1.1rem; font-weight: 700; }
        .elevation-close { background: #ff0080; border: none; color: white; width: 30px; height: 30px; border-radius: 50%; font-size: 1.2rem; cursor: pointer; }
        .elevation-canvas { width: 100%; height: 200px; background: rgba(0,0,0,0.3); border-radius: 8px; margin-top: 10px; }

        /* Summary slide */
        .summary-card { padding: 20px; display: flex; flex-direction: column; justify-content: center; gap: 15px; }
        .summary-title { font-size: 1.5rem; font-weight: 700; color: #00f5ff; text-align: center; text-shadow: 0 0 15px rgba(0,245,255,0.8); }
        .summary-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
        .summary-stat { background: rgba(48,43,99,0.5); border: 2px solid #00f5ff; border-radius: 10px; padding: 12px; text-align: center; }
        .summary-stat-value { font-size: 1.8rem; font-weight: 900; color: #ffaa00; text-shadow: 0 0 10px rgba(255,170,0,0.6); }
        .summary-stat-label { font-size: 0.8rem; color: rgba(255,255,255,0.7); margin-top: 5px; }

    </style>
</head>
<body>
    <!-- Splash Screen -->
    <div class="splash" id="splash">
        <img src="logo.png" alt="G√•pings Mallorca">
        <div class="splash-bar"><div class="splash-fill" id="splashFill" style="width:0%"></div></div>
        <div class="splash-text" id="splashText">Initializing...</div>
    </div>
    
    <!-- Hamburger Menu -->
    <div class="menu-btn" id="menuBtn"><span></span><span></span><span></span></div>
    <div class="menu" id="menu">
        <button class="menu-item" onclick="autoMakeElite(); closeMenu();">‚ö° Auto Elite (A)</button>
        <button class="menu-item" onclick="autoMakeMosjonist(); closeMenu();">üö¥ Auto Mosjonist (B)</button>
        <button class="menu-item" onclick="document.getElementById('gpxInput').click();">üìÅ Last opp GPX</button>
        <button class="menu-item" onclick="clearAll(); closeMenu();">üóëÔ∏è Fjern alle</button>
        <!--<button class="menu-item" onclick="window.location.href='konkurranse-mobil.html';">üèÜ Konkurranse</button>-->
    </div>
    <input type="file" id="gpxInput" accept=".gpx" multiple style="display:none">
    
    <!-- Map -->
    <div id="map"></div>
    
    <!-- FAB Buttons -->
    <div class="fab-group" id="fabGroup">
        <button class="fab download" onclick="downloadCurrentDay()">‚¨áÔ∏è</button>
    </div>
    
    <!-- Route Selector Modal -->
    <div class="modal" id="routeModal">
        <div class="modal-content">
            <div class="modal-header">Velg ruter for <span id="modalDayTitle">Dag 1</span></div>
            <div class="route-selector" id="routeSelector"></div>
            <div class="modal-actions">
                <button class="modal-btn save" onclick="saveRouteSelection()">Lagre</button>
                <button class="modal-btn cancel" onclick="closeRouteSelector()">Avbryt</button>
            </div>
        </div>
    </div>

    <!-- Elevation Profile Modal -->
    <div class="elevation-modal" id="elevationModal">
        <div class="elevation-content">
            <div class="elevation-header">
                <span class="elevation-title" id="elevationTitle">H√∏ydeprofil</span>
                <button class="elevation-close" onclick="closeElevationProfile()">‚úï</button>
            </div>
            <canvas id="elevationCanvas" class="elevation-canvas"></canvas>
        </div>
    </div>
    
    <!-- Day Swiper -->
    <div class="day-swiper">
        <div class="day-cards" id="dayCards">
            <!-- Summary Slide -->
            <div class="day-card summary-card" style="border-top: 4px solid #ff00ff;">
                <div class="summary-title">üìä Sammendrag</div>
                <div class="summary-grid" id="summaryGrid">
                    <div class="summary-stat">
                        <div class="summary-stat-value" id="totalDays">0</div>
                        <div class="summary-stat-label">Dager valgt</div>
                    </div>
                    <div class="summary-stat">
                        <div class="summary-stat-value" id="totalRoutes">0</div>
                        <div class="summary-stat-label">Ruter</div>
                    </div>
                    <div class="summary-stat">
                        <div class="summary-stat-value" id="totalKm">0</div>
                        <div class="summary-stat-label">Totalt km</div>
                    </div>
                    <div class="summary-stat">
                        <div class="summary-stat-value" id="totalHm">0</div>
                        <div class="summary-stat-label">Totalt hm</div>
                    </div>
                </div>
            </div>

            <!-- Dag 1 -->
            <div class="day-card" style="border-top: 4px solid #e74c3c;">
                <div class="day-header">
                    <span class="day-title">Dag 1 - Port de Soller</span>
                    <div class="day-buttons">
                        <button class="profile-btn" onclick="showElevationProfile(0)">üìà</button>
                        <button class="day-select-btn" onclick="openRouteSelector()">Velg</button>
                    </div>
                </div>
                <div class="day-stats" id="day1stats"></div>
                <div class="day-routes" id="day1routes"></div>
            </div>
            <!-- Dag 2 -->
            <div class="day-card" style="border-top: 4px solid #3498db;">
                <div class="day-header">
                    <span class="day-title">Dag 2 - Cap de Formentor</span>
                    <div class="day-buttons">
                        <button class="profile-btn" onclick="showElevationProfile(1)">üìà</button>
                        <button class="day-select-btn" onclick="openRouteSelector()">Velg</button>
                    </div>
                </div>
                <div class="day-stats" id="day2stats"></div>
                <div class="day-routes" id="day2routes"></div>
            </div>

            <!-- Dag 3 -->
            <div class="day-card" style="border-top: 4px solid #2ecc71;">
                <div class="day-header">
                    <span class="day-title">Dag 3 - Sa Calobra</span>
                    <div class="day-buttons">
                        <button class="profile-btn" onclick="showElevationProfile(2)">üìà</button>
                        <button class="day-select-btn" onclick="openRouteSelector()">Velg</button>
                    </div>
                </div>
                <div class="day-stats" id="day3stats"></div>
                <div class="day-routes" id="day3routes"></div>
            </div>

            <!-- Dag 4 -->
            <div class="day-card" style="border-top: 4px solid #f39c12;">
                <div class="day-header">
                    <span class="day-title">Dag 4 - Puig Major</span>
                    <div class="day-buttons">
                        <button class="profile-btn" onclick="showElevationProfile(3)">üìà</button>
                        <button class="day-select-btn" onclick="openRouteSelector()">Velg</button>
                    </div>
                </div>
                <div class="day-stats" id="day4stats"></div>
                <div class="day-routes" id="day4routes"></div>
            </div>
        </div>
        <div class="day-dots" id="dayDots">
            <div class="dot active" onclick="goToDay(0)">üìä</div>
            <div class="dot" onclick="goToDay(1)">1</div>
            <div class="dot" onclick="goToDay(2)">2</div>
            <div class="dot" onclick="goToDay(3)">3</div>
            <div class="dot" onclick="goToDay(4)">4</div>
        </div>
    </div>
    
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-polylinedecorator@1.6.0/dist/leaflet.polylineDecorator.js"></script>
    <script src="js/climb-classifier.js"></script>
    <script>
        let highlightedRouteId = null;

        
        // Inline common code for mobile
        const routes = [];
        const colors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c', '#e67e22', '#34495e', '#16a085', '#c0392b'];
        const dayColors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12'];
        const days = [
            { id: 1, name: 'Dag 1', routes: [], visible: true, color: dayColors[0] },
            { id: 2, name: 'Dag 2', routes: [], visible: true, color: dayColors[1] },
            { id: 3, name: 'Dag 3', routes: [], visible: true, color: dayColors[2] },
            { id: 4, name: 'Dag 4', routes: [], visible: true, color: dayColors[3] }
        ];
        const STORAGE_KEY = 'ggtm26_selected_routes';

        function saveToLocalStorage() {
            const data = days.map(day => ({
                id: day.id,
                routes: day.routes
            }));
            localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
        }

        function loadFromLocalStorage() {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (!saved) return;

            try {
                const parsed = JSON.parse(saved);
                parsed.forEach(savedDay => {
                    const day = days.find(d => d.id === savedDay.id);
                    if (day) {
                        day.routes = savedDay.routes || [];
                    }
                });
            } catch (e) {
                console.warn('Kunne ikke laste lagrede ruter:', e);
            }
        }

        const bundledRouteFiles = [
            'GGTM26_D1_A_Helios_Port_de_Soller_107km_1800hm.gpx',
            'GGTM26_D1_A_Port_de_Soller_Helios_87km_1500hm.gpx',
            'GGTM26_D1_B_Helios_Port_de_Soller_66km_1000hm.gpx',
            'GGTM26_D1_B1_Port_de_Soller_Helios_40km_500hm.gpx',
            'GGTM26_D1_B2_Port_de_Soller_Helios_60km_1100hm.gpx',
            'GGTM26_D2_A_Cap_de_Formentor_Helios_125km_1300hm.gpx',
            'GGTM26_D2_A_Helios_Cap_de_Formentor_108km_1930hm.gpx',
            'GGTM26_D2_B_Helios_Cap_de_Formentor_83km_1000hm.gpx',
            'GGTM26_D2_B1_Cap_de_Formentor_Helios_(tog)_40km_500hm.gpx',
            'GGTM26_D2_B2_Cap_de_Formentor_Helios_(tog)_60km_1100hm.gpx',
            'GGTM26_D3_A_Helios_Sa_Calobra__105km_1900hm.gpx',
            'GGTM26_D3_A_Sa_Calobra__Helios_100km_2300hm.gpx',
            'GGTM26_D3_B_Helios_Sa_Calobra__75km_1100hm.gpx',
            'GGTM26_D3_B1_Sa_Calobra__Helios_70km_1000hm.gpx',
            'GGTM26_D3_B2_Sa_Calobra__Helios_90km_1500hm.gpx',
            'GGTM26_D4_A_Helios_Puig_Major__72km_2400hm.gpx',
            'GGTM26_D4_A_Puig_Major_Helios_100km_1700hm.gpx',
            'GGTM26_D4_B_Helios_Puig_Major__62km_1700hm.gpx',
            'GGTM26_D4_B_Puig_Major_Helios_76km_850hm.gpx'
        ];

        function parseGPX(xmlString) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlString, 'text/xml');
            const points = [];
            const trkpts = xmlDoc.getElementsByTagName('trkpt');
            for (let i = 0; i < trkpts.length; i++) {
                const lat = parseFloat(trkpts[i].getAttribute('lat'));
                const lon = parseFloat(trkpts[i].getAttribute('lon'));
                const eleNode = trkpts[i].getElementsByTagName('ele')[0];
                const ele = eleNode ? parseFloat(eleNode.textContent) : null;
                points.push({ lat, lon, ele });
            }
            return points;
        }

        function calculateStats(points) {
            if (points.length < 2) return null;
            let distance = 0, elevationGain = 0, minEle = points[0].ele, maxEle = points[0].ele;
            for (let i = 1; i < points.length; i++) {
                const p1 = points[i - 1], p2 = points[i];
                const R = 6371;
                const dLat = (p2.lat - p1.lat) * Math.PI / 180;
                const dLon = (p2.lon - p1.lon) * Math.PI / 180;
                const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(p1.lat * Math.PI / 180) * Math.cos(p2.lat * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
                distance += R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                if (p1.ele !== null && p2.ele !== null) {
                    const elevDiff = p2.ele - p1.ele;
                    if (elevDiff > 0) elevationGain += elevDiff;
                }
            }
            return { distance: distance.toFixed(1), elevationGain: Math.round(elevationGain) };
        }

        async function enrichWithElevation(points) {
            console.log('üì° Enriching elevation for', points.length, 'points');
            const targetSamples = 50;
            const sampleRate = Math.max(1, Math.floor(points.length / targetSamples));
            const sampledIndices = [];
            for (let i = 0; i < points.length; i += sampleRate) sampledIndices.push(i);
            if (sampledIndices[sampledIndices.length - 1] !== points.length - 1) sampledIndices.push(points.length - 1);
            
            const locations = sampledIndices.map(i => ({ latitude: points[i].lat, longitude: points[i].lon }));
            
            try {
                const response = await fetch('https://api.open-elevation.com/api/v1/lookup', {
                    method: 'POST',
                    headers: { 'Accept': 'application/json', 'Content-Type': 'application/json' },
                    body: JSON.stringify({ locations })
                });
                
                if (!response.ok) {
                    console.warn('‚ö†Ô∏è Elevation API returned', response.status, '- skipping elevation');
                    return false;
                }
                const data = await response.json();
                data.results.forEach((result, idx) => { points[sampledIndices[idx]].ele = result.elevation; });
                
                // Interpolate between sampled points
                for (let i = 0; i < sampledIndices.length - 1; i++) {
                    const startIdx = sampledIndices[i], endIdx = sampledIndices[i + 1];
                    const startEle = points[startIdx].ele, endEle = points[endIdx].ele;
                    for (let j = startIdx + 1; j < endIdx; j++) {
                        points[j].ele = startEle + (endEle - startEle) * ((j - startIdx) / (endIdx - startIdx));
                    }
                }
                console.log('‚úÖ Elevation enriched successfully');
                return true;
            } catch (error) {
                console.warn('‚ö†Ô∏è Elevation failed:', error.message, '- continuing without elevation');
                return false;
            }
        }

        function autoMakeElite() {
            days.forEach(day => day.routes = []);
            for (let dayNum = 1; dayNum <= 4; dayNum++) {
                const day = days.find(d => d.id === dayNum);
                if (!day) continue;
                const dayARoutes = routes.filter(r => {
                    const match = r.fileName.match(/GGTM26_D(\d+)_A_/);
                    if (!match || parseInt(match[1]) !== dayNum) return false;
                    const afterA = r.fileName.split('_A_')[1];
                    return afterA && !afterA.match(/^[12]/);
                });
                if (dayARoutes.length >= 2) {
                    const utRoute = dayARoutes.find(r => r.fileName.includes('Helios_'));
                    const hjemRoute = dayARoutes.find(r => !r.fileName.includes('Helios_') && r.fileName.includes('_Helios'));
                    if (utRoute && hjemRoute) day.routes.push(utRoute.id, hjemRoute.id);
                    else dayARoutes.slice(0, 2).forEach(route => day.routes.push(route.id));
                }
            }
            saveToLocalStorage();
            updateUI();
            updateMapVisibility();
            closeMenu();
            alert('‚úÖ Elite (A) ruter lastet!');
        }

        function autoMakeMosjonist() {
            days.forEach(day => day.routes = []);
            for (let dayNum = 1; dayNum <= 4; dayNum++) {
                const day = days.find(d => d.id === dayNum);
                if (!day) continue;
                
                // Find all B routes for this day (B, B1, B2)
                const allBRoutes = routes.filter(r => {
                    const match = r.fileName.match(/GGTM26_D(\d+)_B/);
                    return match && parseInt(match[1]) === dayNum;
                });
                
                // Separate B from B1/B2
                const pureB = allBRoutes.filter(r => {
                    const afterD = r.fileName.split(`GGTM26_D${dayNum}_`)[1];
                    return afterD && afterD.startsWith('B_');
                });
                
                const b1b2 = allBRoutes.filter(r => {
                    return r.fileName.includes(`_B1_`) || r.fileName.includes(`_B2_`);
                });
                
                if (pureB.length >= 1) {
                    // We have B routes - prefer these
                    const utRoute = pureB.find(r => r.fileName.includes('Helios_'));
                    const hjemRoute = pureB.find(r => !r.fileName.includes('Helios_') && r.fileName.includes('_Helios'));
                    
                    if (utRoute && hjemRoute) {
                        day.routes.push(utRoute.id, hjemRoute.id);
                    } else if (pureB.length >= 2) {
                        // If can't find UT/HJEM pattern, take first two B
                        pureB.slice(0, 2).forEach(route => day.routes.push(route.id));
                    } else if (pureB.length === 1 && b1b2.length >= 1) {
                        // 1 B route + 1 from B1/B2
                        day.routes.push(pureB[0].id, b1b2[0].id);
                    }
                } else if (b1b2.length >= 2) {
                    // No B routes, use B1 + B2
                    b1b2.slice(0, 2).forEach(route => day.routes.push(route.id));
                }
            }
            saveToLocalStorage();
            updateUI();
            updateMapVisibility();
            closeMenu();
            alert('‚úÖ Mosjonist (B) ruter lastet!');
        }

        function downloadDayGPX(dayId) {
            const day = days.find(d => d.id === dayId);
            if (!day || day.routes.length === 0) { alert('Ingen ruter valgt! Dette er ikke en hviledag - VELG RUTER!'); return; }
            const dayRoutes = day.routes.map(routeId => routes.find(r => r.id === routeId)).filter(r => r);
            if (!dayRoutes[0] || !dayRoutes[0].gpxPoints) { alert('GPX-punkter mangler.'); return; }
            let allPoints = [];
            dayRoutes.forEach(route => { if (route.gpxPoints) allPoints = allPoints.concat(route.gpxPoints); });
            let gpxContent = `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="G√•pings Mallorca Getaway" xmlns="http://www.topografix.com/GPX/1/1">
  <metadata><n>Dag ${dayId}</n></metadata><trk><n>Dag ${dayId}</n><trkseg>
`;
            allPoints.forEach(point => {
                gpxContent += `      <trkpt lat="${point.lat}" lon="${point.lon}">`;
                if (point.ele !== null && point.ele !== undefined) gpxContent += `<ele>${point.ele}</ele>`;
                gpxContent += `</trkpt>
`;
            });
            gpxContent += `    </trkseg></trk></gpx>`;
            const blob = new Blob([gpxContent], { type: 'application/gpx+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `Dag_${dayId}_Mallorca.gpx`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        let map, currentDay = 0;
        
        // Init map
        map = L.map('map').setView([39.6, 2.9], 10);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap'
        }).addTo(map);
        
        // Menu toggle
        document.getElementById('menuBtn').onclick = () => {
            document.getElementById('menu').classList.toggle('active');
            document.getElementById('menuBtn').classList.toggle('active');
        };
        function closeMenu() {
            document.getElementById('menu').classList.remove('active');
            document.getElementById('menuBtn').classList.remove('active');
        }
        
        // Swipe - simplified version
        let startX = 0;
        const swiper = document.querySelector('.day-swiper');
        const cards = document.getElementById('dayCards');
        
        console.log('üéØ SWIPE SETUP:', { swiper: !!swiper, cards: !!cards });
        
        swiper.addEventListener('touchstart', e => {
            startX = e.touches[0].clientX;
            console.log('üëÜ TOUCHSTART at', startX);
        });
        
        swiper.addEventListener('touchend', e => {
            const endX = e.changedTouches[0].clientX;
            const diff = startX - endX;
            console.log('üèÅ TOUCHEND:', { start: startX, end: endX, diff, currentDay });
            
            if (Math.abs(diff) < 50) {
                console.log('‚ùå Too short');
                return;
            }
            
            if (diff > 0 && currentDay < 4) {
                currentDay++;
                console.log('‚û°Ô∏è Next day:', currentDay);
            } else if (diff < 0 && currentDay > 0) {
                currentDay--;
                console.log('‚¨ÖÔ∏è Prev day:', currentDay);
            }
            updateSwiper();
        });
        
        function goToDay(dayIndex) {
            console.log('üéØ goToDay:', currentDay, '‚Üí', dayIndex);
            currentDay = dayIndex;
            updateSwiper();
        }
        
        function updateSwiper() {
            console.log('üîÑ updateSwiper - currentDay:', currentDay);
            cards.style.transform = `translateX(-${currentDay * 100}%)`;
            const dots = document.querySelectorAll('.dot');
            console.log('üîç Found dots:', dots.length);
            dots.forEach((dot, i) => {
                const isActive = i === currentDay;
                dot.classList.toggle('active', isActive);
                console.log(`  Dot ${i}: ${isActive ? 'ACTIVE' : 'inactive'}`);
            });
            highlightedRouteId = null;

            // Hide FAB on summary slide
            const fabGroup = document.getElementById('fabGroup');
            if (fabGroup) {
                fabGroup.style.display = currentDay === 0 ? 'none' : 'flex';
            }

            updateMapVisibility();
            console.log('‚úÖ updateSwiper complete');
        }
        
        function updateMapVisibility() {
            // Summary slide (currentDay === 0) has no routes
            if (currentDay === 0) {
                routes.forEach(route => {
                    route.polyline.setStyle({ opacity: 0 });
                    if (route.decorator) route.decorator.remove();
                    route.startMarker.setStyle({ fillOpacity: 0, opacity: 0 });
                    route.endMarker.setStyle({ fillOpacity: 0, opacity: 0 });
                });
                return;
            }

            const dayIndex = currentDay - 1; // Dag 1 = index 0
            const day = days[dayIndex];
            const selectedRoutes = day.routes.map(id => routes.find(r => r.id === id)).filter(r => r);

            const isHighlighted = highlightedRouteId !== null;

            routes.forEach(route => {
                const isSelected = selectedRoutes.some(r => r.id === route.id);
                const isActive = isHighlighted ? route.id === highlightedRouteId : isSelected;

                route.polyline.setStyle({
                    opacity: isActive ? 0.9 : 0,
                    weight: isActive ? 5 : 3
                });

                // Remove/add decorator instead of setting opacity
                if (route.decorator) {
                    if (isActive) {
                        route.decorator.addTo(map);
                    } else {
                        route.decorator.remove();
                    }
                }

                if (isActive) {
                    route.startMarker.setStyle({ fillOpacity: 0.9, opacity: 1 });
                    route.endMarker.setStyle({ fillOpacity: 0.9, opacity: 1 });
                } else {
                    route.startMarker.setStyle({ fillOpacity: 0, opacity: 0 });
                    route.endMarker.setStyle({ fillOpacity: 0, opacity: 0 });
                }
            });

            if (selectedRoutes.length > 0) {
                const bounds = L.featureGroup(selectedRoutes.map(r => r.polyline)).getBounds();
                map.fitBounds(bounds, { padding: [20, 20] });
            }
        }
        
        function openRouteSelector() {
            if (currentDay === 0) return; // No selection on summary slide

            const modal = document.getElementById('routeModal');
            const selector = document.getElementById('routeSelector');
            const dayNum = currentDay; // currentDay 1-4 = dag 1-4
            document.getElementById('modalDayTitle').textContent = `Dag ${dayNum}`;

            // Filter routes for current day only
            const dayRoutes = routes.filter(r => {
                const match = r.fileName.match(/GGTM26_D(\d+)_/);
                return match && parseInt(match[1]) === dayNum;
            });
            
            selector.innerHTML = '';

                // F√∏r du l√∏kker gjennom dayRoutes
            let bestRoute = null;
            let worstRoute = null;

            dayRoutes.forEach(route => {
                const km = route.stats ? route.stats.distance : 0;
                const hm = route.stats ? route.stats.elevationGain : 0;

                const kmNum = Number(km);
                const hmNum = Number(hm);
                route.score = Math.round(kmNum + hmNum ); // enkel m√•te √• sammenligne totalt "verdi"
                console.log(`Route ${route.fileName}: ${km} km, ${hm} hm, score: ${route.score}`);
            });

            // Finn best og worst basert p√• score
            bestRoute = dayRoutes.reduce((max, route) => (route.score > max.score ? route : max), dayRoutes[0]);
            worstRoute = dayRoutes.reduce((min, route) => (route.score < min.score ? route : min), dayRoutes[0]);


            dayRoutes.forEach(route => {
                const dayIndex = currentDay - 1; // currentDay 1-4 = days[0-3]
                const isSelected = days[dayIndex].routes.includes(route.id);
                const div = document.createElement('div');
                div.className = `route-option ${isSelected ? 'selected' : ''}`;

                // Parse: GGTM26_D1_A_Helios_Port_de_Soller_107km_1800hm.gpx
                const parts = route.fileName.replace('.gpx', '').split('_');
                
                // Extract level (A, B, A1, B2, etc) - it's after DX
                let level = '';
                let levelIndex = -1;
                for (let i = 0; i < parts.length; i++) {
                    if (parts[i].match(/^D\d+$/)) {
                        level = parts[i + 1];
                        levelIndex = i + 1;
                        break;
                    }
                }
                
                // Extract locations between level and km/hm
                const locationParts = [];
                for (let i = levelIndex + 1; i < parts.length; i++) {
                    if (parts[i].match(/^\d+km$/) || parts[i].match(/^\d+hm$/)) break;
                    locationParts.push(parts[i]);
                }
                
                // Build location string: find "Helios" to determine direction
                let fromTo = locationParts.join(' ');
                const heliosIndex = locationParts.indexOf('Helios');
                
                if (heliosIndex !== -1) {
                    // Helios is present
                    if (heliosIndex === 0) {
                        // Helios first: Helios > Destination
                        const destination = locationParts.slice(1).join(' ');
                        fromTo = `Helios > ${destination}`;
                    } else {
                        // Helios last: Origin > Helios
                        const origin = locationParts.slice(0, heliosIndex).join(' ');
                        fromTo = `${origin} > Helios`;
                    }
                }
                
                const name = `${fromTo} (${level})`;
                const km = route.stats ? route.stats.distance : '?';
                const hm = route.stats ? route.stats.elevationGain : '?';
                
                const isBest = route === bestRoute;
                const isWorst = route === worstRoute;

                const badgeHTML = isBest ? `<span class="route-badge best">Best Value!</span>` :
                                isWorst ? `<span class="route-badge worst">Most Beers!</span>` : '';



                div.innerHTML = `
                    <input type="checkbox" id="route-${route.id}" ${isSelected ? 'checked' : ''}>
                    <label for="route-${route.id}">
                        <div class="route-name">${name}</div>
                        <div class="route-details">${km} km | ‚¨ÜÔ∏è ${hm} m</div>
                        ${badgeHTML}
                    </label>
                `;
                div.onclick = (e) => {
                    if (e.target.tagName !== 'INPUT') {
                        const checkbox = div.querySelector('input');
                        const checked = document.querySelectorAll('.route-option input:checked').length;
                        if (!checkbox.checked && checked >= 2) {
                            alert('Maks 2 ruter per dag!');
                            return;
                        }
                        checkbox.checked = !checkbox.checked;
                        div.classList.toggle('selected', checkbox.checked);
                    } else {
                        const checked = document.querySelectorAll('.route-option input:checked').length;
                        if (e.target.checked && checked > 2) {
                            e.target.checked = false;
                            alert('Maks 2 ruter per dag!');
                            return;
                        }
                        div.classList.toggle('selected', e.target.checked);

                        if (div.classList.contains('selected') &&
                            div.querySelector('.route-badge.best')) {
                            triggerConfetti();
                        }
                    }
                };
                selector.appendChild(div);
            });
            
            modal.classList.add('active');
        }
        
        function closeRouteSelector() {
            document.getElementById('routeModal').classList.remove('active');
        }
        
        function saveRouteSelection() {
            const selected = Array.from(document.querySelectorAll('.route-option input:checked'))
                .map(cb => parseInt(cb.id.split('-')[1]));

            const dayIndex = currentDay - 1;
            days[dayIndex].routes = selected;

            saveToLocalStorage(); // üî• LEGG TIL DENNE

            updateUI();
            updateMapVisibility();
            closeRouteSelector();
        }
        
        function addRoute(fileName, points, color) {
            const latLngs = points.map(p => [p.lat, p.lon]);
            const polyline = L.polyline(latLngs, { color, weight: 3, opacity: 0.7 }).addTo(map);

            // Legg til piler for √• vise retning
            const decorator = L.polylineDecorator(polyline, {
                patterns: [{
                    offset: '10%',
                    repeat: '15%',
                    symbol: L.Symbol.arrowHead({
                        pixelSize: 15,
                        polygon: true,
                        pathOptions: {
                            stroke: true,
                            weight: 3,
                            color: color,
                            fillColor: color,
                            fillOpacity: 1.0,
                            opacity: 1.0
                        }
                    })
                }]
            }).addTo(map);

            const startMarker = L.circleMarker(latLngs[0], { radius: 6, fillColor: '#2ecc71', color: '#27ae60', weight: 2, fillOpacity: 0.8 }).addTo(map);
            const endMarker = L.circleMarker(latLngs[latLngs.length-1], { radius: 6, fillColor: '#e74c3c', color: '#c0392b', weight: 2, fillOpacity: 0.8 }).addTo(map);

            routes.push({
                id: routes.length,
                fileName,
                gpxPoints: points,
                polyline,
                decorator,
                startMarker,
                endMarker,
                color,
                originalColor: color,
                stats: calculateStats(points),
                visible: true
            });

            if (routes.length === 1) map.fitBounds(polyline.getBounds());
            updateUI();
        }
        function sortRoutesUtHjem(dayRoutes) {
  if (dayRoutes.length !== 2) return dayRoutes;

  const score = (r) => {
    const name = r.fileName;
    if (name.includes('Helios_')) return 0;      // UT
    if (name.includes('_Helios')) return 1;      // HJEM
    return 2;
  };

  return [...dayRoutes].sort((a, b) => score(a) - score(b));
}

        function updateUI() {
            let totalKm = 0, totalHm = 0, totalDaysWithRoutes = 0, totalRoutesCount = 0;

            days.forEach((day, idx) => {
                const dayRoutes = day.routes.map(id => routes.find(r => r.id === id)).filter(r => r);
                let km = 0, hm = 0;
                dayRoutes.forEach(r => { if(r.stats) { km += parseFloat(r.stats.distance); hm += r.stats.elevationGain; } });

                if (dayRoutes.length > 0) {
                    totalDaysWithRoutes++;
                    totalRoutesCount += dayRoutes.length;
                    totalKm += km;
                    totalHm += hm;
                }

                let statsText = dayRoutes.length ? `${km.toFixed(1)} km | ‚¨ÜÔ∏è ${hm} m` : '';

                // Add overlap percentage if 2 routes
                if (dayRoutes.length === 2) {
                    const overlap = calculateDayOverlap(dayRoutes);
                    if (overlap > 0) {
                        statsText += ` | üîó ${overlap}% samme vei`;
                    }
                }

                document.getElementById(`day${idx+1}stats`).textContent = statsText;

                const routesContainer = document.getElementById(`day${idx+1}routes`);

if (!dayRoutes.length) {
  routesContainer.innerHTML = '';
  return;
}

const sortedRoutes = sortRoutesUtHjem(dayRoutes);

routesContainer.innerHTML = `
  <div class="route-timeline">
    ${sortedRoutes.map((r, i) => {
      const parts = r.fileName.replace('.gpx', '').split('_');

      let levelIndex = parts.findIndex(p => p.match(/^D\d+$/)) + 1;
      const locationParts = [];

      for (let j = levelIndex + 1; j < parts.length; j++) {
        if (parts[j].match(/^\d+km$/) || parts[j].match(/^\d+hm$/)) break;
        locationParts.push(parts[j]);
      }

      let fromTo = locationParts.join(' ');
      const heliosIndex = locationParts.indexOf('Helios');

      if (heliosIndex !== -1) {
        if (heliosIndex === 0) {
          fromTo = `Helios ‚Üí ${locationParts.slice(1).join(' ')}`;
        } else {
          fromTo = `${locationParts.slice(0, heliosIndex).join(' ')} ‚Üí Helios`;
        }
      }

      return `
        <div class="route-leg"
             style="border-left-color:${day.color}"
             onclick="highlightedRouteId=${r.id}; updateMapVisibility();">
          <div class="route-leg-index">${i + 1}</div>
          <div class="route-leg-content">
            <div class="route-leg-name">${fromTo}</div>
            <div class="route-leg-stats">
              ${r.stats ? `${r.stats.distance} km ¬∑ ‚¨ÜÔ∏è ${r.stats.elevationGain} m` : ''}
            </div>
          </div>
        </div>
        ${i === 0 && sortedRoutes.length === 2 ? `<div class="route-connector"></div>` : ''}
      `;
    }).join('')}
  </div>
`;


                
                // Update route colors and decorator colors
                dayRoutes.forEach(r => {
                    r.polyline.setStyle({ color: day.color });
                    if (r.decorator) {
                        r.decorator.remove();
                        r.decorator = L.polylineDecorator(r.polyline, {
                            patterns: [{
                                offset: '10%',
                                repeat: '15%',
                                symbol: L.Symbol.arrowHead({
                                    pixelSize: 15,
                                    polygon: true,
                                    pathOptions: {
                                        stroke: true,
                                        weight: 3,
                                        color: day.color,
                                        fillColor: day.color,
                                        fillOpacity: 1.0,
                                        opacity: 1.0
                                    }
                                })
                            }]
                        }).addTo(map);
                    }
                });
            });

            // Update summary slide
            document.getElementById('totalDays').textContent = totalDaysWithRoutes;
            document.getElementById('totalRoutes').textContent = totalRoutesCount;
            document.getElementById('totalKm').textContent = totalKm.toFixed(0);
            document.getElementById('totalHm').textContent = Math.round(totalHm);
        }
        
        async function loadBundledRoutes() {
            const splashFill = document.getElementById('splashFill');
            const splashText = document.getElementById('splashText');
            
            for (let i = 0; i < bundledRouteFiles.length; i++) {
                const fileName = bundledRouteFiles[i];
                splashText.textContent = `${i+1} av ${bundledRouteFiles.length} - ${fileName.substring(0, 30)}...`;
                
                try {
                    const response = await fetch(`routes/${encodeURIComponent(fileName)}`);
                    const gpxContent = await response.text();
                    const points = parseGPX(gpxContent);
                    
                    const hasElevation = points.some(p => p.ele !== null);
                    console.log(`üìä ${fileName}: ${hasElevation ? '‚úÖ HAS' : '‚ùå NO'} elevation data (${points.length} points)`);
                    
                    if (!hasElevation) {
                        console.log('üîÑ Fetching elevation from API...');
                        await enrichWithElevation(points);
                    } else {
                        console.log('‚úÖ Using GPX elevation data');
                    }
                    
                    addRoute(fileName, points, colors[routes.length % colors.length]);
                } catch (error) {
                    console.error(`Failed: ${fileName}`);
                }
                
                splashFill.style.width = `${((i+1) / bundledRouteFiles.length) * 100}%`;
            }
            loadFromLocalStorage();
            splashText.textContent = 'Ferdig!';
            setTimeout(() => document.getElementById('splash').classList.add('hidden'), 500);
        }
        
        document.getElementById('gpxInput').onchange = async (e) => {
            const files = Array.from(e.target.files);
            if (!files.length) return;

            document.getElementById('splash').classList.remove('hidden');
            const splashFill = document.getElementById('splashFill');
            const splashText = document.getElementById('splashText');

            const newRouteIds = []; // Track newly added routes for auto-assignment

            for (let i = 0; i < files.length; i++) {
                const fileName = files[i].name;

                // Check for duplicate filename
                if (routes.some(r => r.fileName === fileName)) {
                    alert(`‚ö†Ô∏è "${fileName}" er allerede lastet opp! Hopper over...`);
                    continue;
                }

                splashText.textContent = `${i+1} av ${files.length} - ${fileName}`;
                const content = await files[i].text();
                const points = parseGPX(content);
                if (!points.some(p => p.ele !== null)) await enrichWithElevation(points);
                const routeId = routes.length;
                addRoute(fileName, points, colors[routes.length % colors.length]);
                newRouteIds.push(routeId);
                splashFill.style.width = `${((i+1) / files.length) * 100}%`;
            }

            // Auto-assign newly uploaded routes to current day (if not on summary slide)
            if (newRouteIds.length > 0 && currentDay > 0) {
                const dayIndex = currentDay - 1;
                const day = days[dayIndex];
                newRouteIds.forEach(routeId => {
                    if (!day.routes.includes(routeId)) {
                        day.routes.push(routeId);
                    }
                });
                updateUI();
                updateMapVisibility();
            }

            setTimeout(() => document.getElementById('splash').classList.add('hidden'), 500);
            e.target.value = '';
        };
        
        function clearAll() {
            routes.forEach(r => {
                r.polyline.remove();
                if (r.decorator) r.decorator.remove();
                r.startMarker.remove();
                r.endMarker.remove();
            });
            routes.length = 0;
            days.forEach(d => d.routes = []);
            updateUI();
        }

        // Calculate overlap percentage for a day with 2 routes
        function calculateDayOverlap(dayRoutes) {
            if (dayRoutes.length !== 2) return 0;

            const coords1 = dayRoutes[0].polyline.getLatLngs().map(ll => ({ lat: ll.lat, lng: ll.lng }));
            const coords2 = dayRoutes[1].polyline.getLatLngs().map(ll => ({ lat: ll.lat, lng: ll.lng }));

            const tolerance = 0.0005;
            let overlapPoints = 0;
            const totalComparisons = coords1.length;

            for (let i = 0; i < coords1.length - 1; i++) {
                const seg1Start = coords1[i];
                const seg1End = coords1[i + 1];

                for (let j = 0; j < coords2.length - 1; j++) {
                    const seg2Start = coords2[j];
                    const seg2End = coords2[j + 1];

                    const dist = Math.sqrt(Math.pow(seg1Start.lat - seg2Start.lat, 2) + Math.pow(seg1Start.lng - seg2Start.lng, 2));
                    if (dist < tolerance) {
                        const dir1 = { lat: seg1End.lat - seg1Start.lat, lng: seg1End.lng - seg1Start.lng };
                        const dir2 = { lat: seg2End.lat - seg2Start.lat, lng: seg2End.lng - seg2Start.lng };
                        const dotProduct = dir1.lat * dir2.lat + dir1.lng * dir2.lng;
                        if (dotProduct > 0) {
                            overlapPoints++;
                            break;
                        }
                    }
                }
            }

            return totalComparisons > 0 ? (overlapPoints / totalComparisons * 100).toFixed(1) : 0;
        }

        // Show elevation profile for a day (FULL DESKTOP VERSION)
        function showElevationProfile(dayIndex) {
            const day = days[dayIndex];
            let dayRoutes;
            let profileTitle = '';

            // If day has routes, use those. Otherwise, use all loaded routes
            if (day && day.routes.length > 0) {
                dayRoutes = day.routes.map(id => routes.find(r => r.id === id)).filter(r => r);
                profileTitle = `Dag ${dayIndex + 1}`;
            } else if (routes.length > 0) {
                // Fallback: show all routes if no routes selected for this day
                dayRoutes = routes;
                profileTitle = 'Alle ruter';
            } else {
                alert('Ingen ruter lastet! Last opp GPX-filer eller velg ruter f√∏rst.');
                return;
            }

            const pointsWithEle = [];
            dayRoutes.forEach(route => {
                if (route.gpxPoints) pointsWithEle.push(...route.gpxPoints);
            });

            if (pointsWithEle.length === 0 || !pointsWithEle.some(p => p.ele !== null)) {
                alert('Ingen h√∏ydedata tilgjengelig!');
                return;
            }

            window.champagneShown = false;
            const dayId = dayIndex + 1;
            document.getElementById('elevationModal').classList.add('active');

            const canvas = document.getElementById('elevationCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            const elevations = pointsWithEle.map(p => p.ele || 0);
            const minEle = Math.min(...elevations);
            const maxEle = Math.max(...elevations);

            // Calculate cumulative distances
            const cumulativeDistance = [0];
            for (let i = 1; i < pointsWithEle.length; i++) {
                const p1 = pointsWithEle[i - 1];
                const p2 = pointsWithEle[i];
                const R = 6371;
                const dLat = (p2.lat - p1.lat) * Math.PI / 180;
                const dLon = (p2.lon - p1.lon) * Math.PI / 180;
                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                          Math.cos(p1.lat * Math.PI / 180) * Math.cos(p2.lat * Math.PI / 180) *
                          Math.sin(dLon/2) * Math.sin(dLon/2);
                const dist = R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                cumulativeDistance.push(cumulativeDistance[i-1] + dist);
            }
            const totalDistance = cumulativeDistance[cumulativeDistance.length - 1];

            function drawBackground() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.strokeStyle = 'rgba(0,245,255,0.2)';
                ctx.lineWidth = 1;
                ctx.fillStyle = '#00f5ff';
                ctx.font = '9px Courier New';
                ctx.textAlign = 'left';

                for (let i = 0; i <= 5; i++) {
                    const elevationAtLine = maxEle - ((maxEle - minEle) / 5) * i;
                    const y = canvas.height - ((elevationAtLine - minEle) / (maxEle - minEle)) * (canvas.height - 20);
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                    ctx.fillText(`${elevationAtLine.toFixed(0)}m`, 5, y + 10);
                }
            }

            const peakIndexes = findPeaks(elevations, cumulativeDistance, dayId);
            let totalClimbingPoints = 0;
            peakIndexes.forEach(peak => totalClimbingPoints += peak.score);

            const dayNames = ['Port de Soller', 'Cap de Formentor', 'Sa Calobra', 'Puig Major'];
            let title = profileTitle;
            if (profileTitle.startsWith('Dag ') && dayId >= 1 && dayId <= 4) {
                title = `Dag ${dayId} (${dayNames[dayId - 1]})`;
            }
            document.getElementById('elevationTitle').textContent = `${title} - ${totalClimbingPoints}p`;

            let meetIdx = dayRoutes.length > 1 ? dayRoutes[0].gpxPoints.length - 1 : Math.floor(pointsWithEle.length / 2);
            const meetX = cumulativeDistance[meetIdx] / totalDistance * canvas.width;
            const meetY = canvas.height - ((pointsWithEle[meetIdx].ele - minEle)/(maxEle - minEle))*(canvas.height-20);

            let progress = 0;
            const animationDuration = 1200;
            let startTime = null;
            const peaks = [];
            const shownPeaks = new Set();

            function animateProfile(timestamp) {
                if (!startTime) startTime = timestamp;
                const elapsed = timestamp - startTime;
                progress = Math.min(elapsed / animationDuration, 1);

                drawBackground();

                const maxIndex = Math.floor(progress * (pointsWithEle.length - 1));

                // Draw zones progressively - only up to current animation position
                peakIndexes.forEach(peak => {
                    if (peak.category && maxIndex >= peak.startIndex) {
                        let color;
                        switch(peak.category) {
                            case 'HC': color = 'rgba(255, 100, 100, 1)'; break;
                            case '1': color = 'rgba(255, 0, 255, 1)'; break;
                            case '2': color = 'rgba(160, 100, 255, 1)'; break;
                            case '3': color = 'rgba(0, 180, 255, 1)'; break;
                            case '4': color = 'rgba(0, 245, 255, 1)'; break;
                        }

                        ctx.fillStyle = color;
                        ctx.beginPath();
                        const startX = cumulativeDistance[peak.startIndex] / totalDistance * canvas.width;
                        ctx.moveTo(startX, canvas.height);

                        // Only draw zone up to current animation position
                        const endDrawIndex = Math.min(peak.index, maxIndex);
                        for (let i = peak.startIndex; i <= endDrawIndex; i++) {
                            const x = cumulativeDistance[i] / totalDistance * canvas.width;
                            const y = canvas.height - ((elevations[i] - minEle) / (maxEle - minEle)) * (canvas.height - 20);
                            ctx.lineTo(x, y);
                        }

                        const endX = cumulativeDistance[endDrawIndex] / totalDistance * canvas.width;
                        ctx.lineTo(endX, canvas.height);
                        ctx.closePath();
                        ctx.fill();
                    }
                });

                // Draw the line
                ctx.beginPath();
                ctx.strokeStyle = '#00f5ff';
                ctx.lineWidth = 2;
                for (let i = 0; i <= maxIndex; i++) {
                    const x = cumulativeDistance[i] / totalDistance * canvas.width;
                    const y = canvas.height - ((elevations[i] - minEle) / (maxEle - minEle)) * (canvas.height - 20);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);

                    for (let peak of peakIndexes) {
                        if (i === peak.index && !shownPeaks.has(peak.index)) {
                            peaks.push({ x, y, life: 0, index: peak.index, category: peak.category, midIndex: peak.midIndex });
                            shownPeaks.add(peak.index);
                        }
                    }
                }
                ctx.stroke();

                for (let i = peaks.length - 1; i >= 0; i--) {
                    const star = peaks[i];
                    star.life += 0.02;
                    const rise = star.life * 40;
                    const opacity = 1 - star.life;
                    if (opacity <= 0) {
                        peaks.splice(i, 1);
                        continue;
                    }
                    ctx.save();
                    ctx.globalAlpha = opacity;
                    drawStar(ctx, star.x, star.y - rise, 5, 8, 4);
                    ctx.restore();
                }

                if (progress >= 1) {
                    peakIndexes.forEach(peak => {
                        if (peak.category) {
                            const midX = cumulativeDistance[peak.midIndex] / totalDistance * canvas.width;
                            const midY = canvas.height - ((elevations[peak.midIndex] - minEle) / (maxEle - minEle)) * (canvas.height - 20);

                            ctx.beginPath();
                            ctx.arc(midX, midY, 14, 0, 2 * Math.PI);
                            ctx.fillStyle = '#e74c3c';
                            ctx.fill();
                            ctx.strokeStyle = '#fff';
                            ctx.lineWidth = 2;
                            ctx.stroke();

                            ctx.fillStyle = '#fff';
                            ctx.font = 'bold 11px Arial';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(peak.category, midX, midY);
                        }
                    });
                }

                if (dayId !== 4 && maxIndex >= meetIdx) {
                    ctx.save();
                    ctx.font = '28px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('üç∫', meetX, meetY - 14);
                    ctx.restore();
                }

                if (dayId === 4 && progress >= 1) {
                    const lastIdx = pointsWithEle.length - 1;
                    const endX = (cumulativeDistance[lastIdx] / totalDistance) * canvas.width;
                    const endY = canvas.height - ((elevations[lastIdx] - minEle) / (maxEle - minEle)) * (canvas.height - 20);

                    if (!window.champagneShown) {
                        window.champagneShown = true;
                        const rect = canvas.getBoundingClientRect();
                        triggerConfettiAt(rect.left + endX - 15, rect.top + endY - 30);
                    }

                    ctx.save();
                    ctx.font = '28px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('ü•Ç', endX - 15, endY - 30);
                    ctx.restore();
                }

                if (progress < 1 || peaks.length > 0) {
                    requestAnimationFrame(animateProfile);
                }
            }

            requestAnimationFrame(animateProfile);

            setTimeout(() => {
                ctx.fillStyle = '#00f5ff';
                ctx.font = '10px Courier New';
                ctx.fillText(`${totalDistance.toFixed(1)}km`, canvas.width - 50, canvas.height - 5);
            }, animationDuration + 100);
        }

        // Find peaks with climb classification
        function findPeaks(elev, dist, dayId) {
            const W = 6;
            const MAX_PEAKS = 9;
            const MIN_PROMINENCE = 100;
            const MIN_DISTANCE_KM = 2.5;
            const MIN_ELEVATION = 300;

            let candidates = [];
            for (let i = W; i < elev.length - W; i++) {
                const current = elev[i];
                if (current < MIN_ELEVATION) continue;

                const before = Math.max(...elev.slice(i - W, i));
                const after = Math.max(...elev.slice(i + 1, i + W + 1));

                if (current >= before && current >= after) {
                    candidates.push({ index: i, elevation: current, distance: dist[i] });
                }
            }

            candidates.sort((a, b) => b.elevation - a.elevation);

            const selected = [];
            for (let peak of candidates) {
                if (selected.length === 0) {
                    selected.push(peak);
                    continue;
                }

                let tooClose = false;
                for (let prev of selected) {
                    const distDiff = Math.abs(peak.distance - prev.distance);

                    if (distDiff < MIN_DISTANCE_KM) {
                        tooClose = true;
                        break;
                    }

                    const startIdx = Math.min(prev.index, peak.index);
                    const endIdx = Math.max(prev.index, peak.index);
                    const minBetween = Math.min(...elev.slice(startIdx, endIdx + 1));
                    const lowerPeak = Math.min(prev.elevation, peak.elevation);
                    const prominence = lowerPeak - minBetween;

                    if (prominence < MIN_PROMINENCE) {
                        tooClose = true;
                        break;
                    }
                }

                if (!tooClose) {
                    selected.push(peak);
                }

                if (selected.length >= MAX_PEAKS) break;
            }

            const peaksWithCategory = selected.map(peak => {
                let searchStart = 0;
                for (let i = 0; i < selected.length; i++) {
                    if (selected[i].index < peak.index && selected[i].index > searchStart) {
                        searchStart = selected[i].index;
                    }
                }

                let valleyIndex = searchStart;
                let lowestEle = elev[searchStart];
                for (let i = searchStart; i < peak.index; i++) {
                    if (elev[i] < lowestEle) {
                        lowestEle = elev[i];
                        valleyIndex = i;
                    }
                }

                let climbStart = valleyIndex;
                let climbDistanceKm = dist[peak.index] - dist[climbStart];
                let climbGain = elev[peak.index] - elev[climbStart];
                let avgGradient = climbDistanceKm > 0 ? (climbGain / (climbDistanceKm * 1000)) * 100 : 0;

                if (avgGradient < CLIMB_CONFIG.minGradient && climbDistanceKm > CLIMB_CONFIG.minLength) {
                    let bestStart = climbStart;
                    let bestGradient = avgGradient;

                    for (let i = climbStart + 1; i < peak.index; i++) {
                        const testDistKm = dist[peak.index] - dist[i];
                        const testGain = elev[peak.index] - elev[i];
                        const testGradient = testDistKm > 0 ? (testGain / (testDistKm * 1000)) * 100 : 0;

                        if (testDistKm >= CLIMB_CONFIG.minLength &&
                            testGain >= CLIMB_CONFIG.minElevation &&
                            testGradient >= CLIMB_CONFIG.minGradient) {
                            bestStart = i;
                            bestGradient = testGradient;
                            break;
                        }
                    }

                    if (bestStart !== climbStart) {
                        climbStart = bestStart;
                        climbDistanceKm = dist[peak.index] - dist[climbStart];
                        climbGain = elev[peak.index] - elev[climbStart];
                        avgGradient = bestGradient;
                    }
                }

                const classification = classifyClimb(climbGain, climbDistanceKm);
                const category = classification ? classification.category : null;
                const score = classification ? classification.points : 0;
                const midIndex = Math.floor((climbStart + peak.index) / 2);

                return {
                    index: peak.index,
                    startIndex: climbStart,
                    midIndex: midIndex,
                    category: category,
                    score: score
                };
            });

            return peaksWithCategory;
        }

        // Draw star function
        function drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
            let rot = Math.PI / 2 * 3;
            let x = cx;
            let y = cy;
            const step = Math.PI / spikes;

            ctx.beginPath();
            ctx.moveTo(cx, cy - outerRadius);

            for (let i = 0; i < spikes; i++) {
                x = cx + Math.cos(rot) * outerRadius;
                y = cy + Math.sin(rot) * outerRadius;
                ctx.lineTo(x, y);
                rot += step;

                x = cx + Math.cos(rot) * innerRadius;
                y = cy + Math.sin(rot) * innerRadius;
                ctx.lineTo(x, y);
                rot += step;
            }

            ctx.lineTo(cx, cy - outerRadius);
            ctx.closePath();

            ctx.fillStyle = '#ffd700';
            ctx.fill();
        }

        // Trigger confetti at position
        function triggerConfettiAt(x, y) {
            const container = document.getElementById('confetti-container');
            if (!container) return;

            for (let i = 0; i < 40; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';

                const angle = Math.random() * 2 * Math.PI;
                const distance = 80 + Math.random() * 80;

                confetti.style.left = `${x}px`;
                confetti.style.top = `${y}px`;

                confetti.style.setProperty('--x', `${Math.cos(angle) * distance}px`);
                confetti.style.setProperty('--y', `${Math.sin(angle) * distance}px`);

                confetti.style.backgroundColor = `hsl(${Math.random() * 360}, 100%, 60%)`;

                container.appendChild(confetti);

                setTimeout(() => confetti.remove(), 3000);
            }
        }

        function closeElevationProfile() {
            document.getElementById('elevationModal').classList.remove('active');
        }
        
        function downloadCurrentDay() {
            // currentDay 0 = summary, currentDay 1-4 = dag 1-4
            if (currentDay === 0) return; // Should not happen as FAB is hidden
            downloadDayGPX(currentDay);
        }
        
        loadBundledRoutes();

        // Konfetti-funksjon
    function triggerConfetti() {
        const container = document.getElementById('confetti-container');
        const numConfetti = 50; // flere biter

        for (let i = 0; i < numConfetti; i++) {
            const confetti = document.createElement('div');
            confetti.classList.add('confetti');

            // tilfeldig farge
            confetti.style.backgroundColor = `hsl(${Math.random() * 360}, 80%, 60%)`;

            // startposisjon (midten av skjermen / kan justeres til badge)
            confetti.style.left = `${window.innerWidth / 2}px`;
            confetti.style.top = `${window.innerHeight / 3}px`;

            // tilfeldig retning og avstand
            const x = (Math.random() - 0.5) * 400; // -200 til +200 px
            const y = (Math.random() - 0.5) * 300; // -150 til +150 px
            confetti.style.setProperty('--x', `${x}px`);
            confetti.style.setProperty('--y', `${y}px`);

            // tilfeldig st√∏rrelse
            const size = 8 + Math.random() * 8;
            confetti.style.width = `${size}px`;
            confetti.style.height = `${size}px`;

            // legg til i container
            container.appendChild(confetti);

            // fjern etter animasjon
            setTimeout(() => container.removeChild(confetti), 1500);
        }
    }

    </script>
    <div id="confetti-container"></div>
</body>
</html>
